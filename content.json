{"meta":{"title":"Somnus's blog","subtitle":null,"description":null,"author":"Somnus","url":"https://Foxgrin.github.io"},"pages":[],"posts":[{"title":"","slug":"111","date":"2018-07-09T14:05:53.084Z","updated":"2018-07-09T14:05:57.505Z","comments":true,"path":"/posts/6/","link":"","permalink":"https://Foxgrin.github.io/posts/6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sql-labs50-53","slug":"sql-labs50-53","date":"2018-07-09T09:08:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/58721/","link":"","permalink":"https://Foxgrin.github.io/posts/58721/","excerpt":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡","text":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡 Less50-53Less-50输入sort=1,2,3得到正常排序的表，输入sort=1’和sort=1”都报错，说明没有引号包裹 先试试rand() 再试试报错注入 延时注入 发现都可以正常注入 看一下源代码 发现多重查询 说明这关可以进行堆叠注入 发现添加了新的一行 被单引号包裹 Less-52 被单引号包裹，没有报错信息 对堆叠注入没有影响 Less-53 被单引号包裹，并且没有报错，依然对堆叠没有影响","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs46-49","slug":"sql-labs46-49","date":"2018-07-09T08:38:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/15069/","link":"","permalink":"https://Foxgrin.github.io/posts/15069/","excerpt":"总结了sql-labs中关于order by后面的注入的一些关卡","text":"总结了sql-labs中关于order by后面的注入的一些关卡 Less46-49Less46首先页面呈现 要我们get方式输入一个名为sort的参数 那我们输入/?sort=1 发现输出了users表里面的信息 输入sort=2时，发现排序变化了，按照第二列username的值进行了排序，于是猜测sql语句为select * from users order by get[‘sort’]， 但是，又有个问题，之前的关卡都是将查询的结果利用mysql_fetch_array($result)=$row，这样都是输出一行结果，为什么这关输出了所有的结果 看一下源代码 Sql语句与猜想的一样 如果查询的结果不为空，那么 建立一个表格 Th标签能使里面的文件加粗并居中，td标签里的文本是默认向左对齐，不加粗 这是最关键的代码，和之前关卡不一样，这里用到了新的一个函数，mysql_fetch_assoc() 经过查询，这个函数与mysql_fetch_array区别只在于前者返回的是关联数组，而后者既能返回关联数组又能返回索引数组 而要返回多个结果，就需要while循环，如果不用while循环，那么只能返回一个查询结果 源代码搞懂了，那么怎么进行注入呢 输入sort=1 desc，变成降序排列，默认是asc，也就是升序排列 我们通过sql语句观察出这题注入点应该是order by 后面的数字 先认识一个随机查询，select * from users order by rand() Rand()函数是随机产生一个0到1之间的数字 可以看出两次产生的是不同的随机数 而如果在括号内指定参数即rand(0)和rand(1)，则会产生固定的随机数种子 随机查询就是利用rand()函数产生不同的随机数种子，这些产生的随机数进行order by 排序，order by后面的参数如果是产生固定的随机数种子，随机排序的表就是固定的 于是我们利用在rand()函数的参数中构造逻辑表达式，根据返回的表判断逻辑表达式的真假，从而进行注入，比如/?sort=rand(ascii(substr(database(),1,1))=115) 发现返回是rand(false)也就是rand(0)的随机排序表，说明上述逻辑表达式为假 我们再先试试union查询可不可以 报错了，是不是union 和order by不能一起使用了，我们在mysql命令行中测试一下，发现以下两种是不会报错的，一种是在联合两边的select 语句分别加括号，一种是将order by放入后面的select语句 为什么呢，经过查询发现union查询并不是只是简简单单的将两个子查询结果进行拼接，而是将两个查询结果统一查询，所以order by 应该放在最后一个子查询中 然而这关我们是在order by后进行注入，所以不能使用union注入 那能不能使用延时注入呢，也就是通过order by 1 and if(,1,sleep()) 我们先在mysql命令行中测试一下 发现sleep了18秒，猜测是因为有18秒的原因，至于为什么是排序成这样，请教学长，学长也无法解释，暂时将这个问题搁在一边，但是抛开这个问题，利用这个方法进行延时注入是可行的，经过测试只要保证order by后面的参数不会报错，就能执行and后面的语句，经过测试带小数的数字，任何字符和字符串，列名，1,2,3都不会报错，但只有列名和1,2,3当做参数，才会对表排序，其他都会得到原来的表 下面试试延时注入 成功延时9秒 再试试能不能通过and 进行报错注入 非常完美，那么就可以进行熟悉爆表爆列了 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),0x3a)) http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),0x3a)) 那么count(),group by,floor(rand(0)2)的报错注入能不能在这里运用呢 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%201=(select%20count(*)%20from%20information_schema.columns%20group%20by%20concat(0x3a,database(),0x3a,floor(rand(0)*2))) 没问题，但除此之外还有一种方法进行这种报错注入，就是利用sort=(select …)进行报错注入 还有一种方法，可以在order by后面的procedure analyse参数进行报错注入 但是这里又碰到一个问题，procedure analyse后面的报错注入，加入子查询语句会报错，原因未知，可能是语法错误，暂时来看这个方法只能注出库名，用户名和版本 Into outfile 注入 Less-47输入sort=1,2,3发现都得到原来的表，猜测sort可能被引号包裹，成为字符，所以排序后仍为原来的表，加个单引号 发现报错了，果然被单引号包裹了 先试试随机查询rand() 还是原来的表，说明这里用rand()是不行的 那么用and +报错注入 延时注入 另外一种报错注入，经过测试必须通过and 后面才能执行，之前关卡的sort=(select …)方法测试不会报错 Procedure analyse 报错注入 Less-48输入sort=1,2,3，发现正常排序，说明sort没有被引号包裹，输入1’ 发现没有报错，说明不返回报错信息，所以这关不能用报错注入 排除sort=(select count(*))注入和and +报错和procedure analyse 报错注入 那么试试sort=rand()注入 这是rand(true)排序的表 这是rand(false)排序的表 再试试 and +延时注入 导出文件 Less-49输入sort=1,2,3发现都得到原来的表，说明有引号包裹，在输入sort=1’，没有输出表，没有报错，说明被单引号包裹，并且没有返回报错信息 那么排除了报错注入，rand()，那只能延时注入和导出文件了 文件导出","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs38-45","slug":"sql-labs38-45","date":"2018-07-09T08:07:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/5994/","link":"","permalink":"https://Foxgrin.github.io/posts/5994/","excerpt":"总结了sql-labs中堆叠注入的一些关卡","text":"总结了sql-labs中堆叠注入的一些关卡 Less38-45Less-38一开始做这关发现跟之前关卡没有什么区别，可以正常的注出数据库等信息 但是这关要考察的是堆叠注入，也就是多语句查询，我们在mysql命令行中就可以验证，在前面一个sql语句结尾加上;，再加入一个sql语句，mysql就会一起执行这两个sql语句 可以看出两个语句都执行了 然而在之前关卡试了一下，是不能堆叠注入，看看这关源代码，发现与之前关卡连接数据库的方式变化了 这里用了mysqli函数来连接数据库 查询一下mysqli连接方式跟之前mysql连接方式，大致区别就是mysqli是一种新型的连接方式，然后应用在本关就能支持堆叠注入，原因它有个支持多查询的函数 由于第二个查询是网页上是看不到结果，即使有错误信息也是看不到的，所以一般不用查询语句来堆叠注入 例如可以进行一些数据库数据表的增删改操作，然后在mysql命令行进行验证 例如创建一个数据表test 删去表test 往users表中添加信息 即使第二条语句出现错误，我们也不会看到报错信息，所以一定要保证输入的语句不会出现错误 Less-39这关跟上一关区别就在于id没有被包裹 Less-40这关id值被(‘’)包裹，其他的跟之前没区别 测试一下延时注入是否使用在堆叠注入 经过测试是不行的，因为服务器只会返回给我们的第一个语句查询结果，第二个语句虽然会执行，但是结果是不会返回给我们的 Less-41这关id没有被包裹，其余与之前关卡无区别 Less-42刚进入这关从页面来看有点像之前的二次注入，之前的二次注入思路是创建一个名为admin’#的用户，然后登陆这个用户，修改密码，由于修改密码页面的sql语句条件中的username是直接从session中取的，不经过过滤，所以通过二次注入，最终修改了admin用户的密码 而这关想创建新用户，发现 提示我们如果要创建新用户，就用黑客的方法 我们想到这几关的主题，堆叠注入，那么是不是可以通过堆叠注入，将admin’#用户名直接写入users表中，这样就不需要通过之前创建用户的方式来二次注入 看一下login.php的源代码 果然允许多查询 那么来找找注入点 发现password未经过过滤，所以我们就在password进行注入 成功登陆 并且添加admin’# 接下来登陆admin’# 并修改密码 发现admin密码被修改，成功通过堆叠注入实现二次注入 其他数据库和数据表增添，删改和之前关卡一样 另外本关还可以报错注入 Less-43 Password被（‘’）包裹，方法与上一关相同 Less-44这关没有报错信息，所以只能先延时注入 被单引号包裹 其他与之前关卡相同，就是不能报错注入了 Less-45一样没有报错信息，延时注入 被(‘’)包裹，其他与之前相同","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs29-37","slug":"sql-labs29-37","date":"2018-07-09T07:13:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/56021/","link":"","permalink":"https://Foxgrin.github.io/posts/56021/","excerpt":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡","text":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡 Less29-37Less-29 首先页面信息展示的是“这个页面受到世界上最好的防火墙的保护” n 经过一系列盲注，发现都没有什么特别的地方 看一下源码，发现这关有隐藏的登录页面 输入id=1 输入id=1’ 发现直接跳转到另外一个页面，尝试一系列盲注，都被防火墙拦截下来 看一下login.php的源码 首先，我们输入的请求信息以字符串的方式被截取下来 然后这个字符串被以&amp;为分隔符组合成数组 并且如果有一个元素是id=(某个值)，这个值被截取下来赋值给id_value 并判断这个值，如果不是完全由数字组成的，则跳转到被防火墙拦截页面 这个处理实际上就是服务器处理数据的原理 http服务器实际上有两个，当客户端发送请求数据给服务器时，数据会先经过第一个tomcat服务器，tomcat服务器先处理第一个请求参数，再将数据交给第二个apache服务器，apache服务器处理最后一个请求参数，将结果返回给tomcat,tomcat再返回给客户端 也就是说当我们输入/login.php?id=1&amp;id=2，最后服务器处理的是id=2这个参数，也就是最后一个参数 这关的代码实际上就是模仿在tomcat服务器设置防火墙，从而进行数据过滤，防止攻击 所以我们就可以用第一个参数骗过服务器，通过最后一个参数进行sql注入，这就属于hpp，也就是http参数污染漏洞攻击 第一个参数输入纯数字，第二个参数进行注入 剩下的就跟之前相同了 Less-30这题跟上题区别在于id被双引号包裹，其他方法跟上题相同 Less-31这题id被(“”)包裹，其余和前两题一样 Less-32输入id=1 再输入id=1’ 发现我们输入的值被经过处理了 查看源代码 Preg_quote()这个函数作用是在正则表达式中将特殊字符转义，比如一些在正则表达式中具有特殊意义的字符*-?等，如果不加以转义会被认为是特殊字符无法替换 还有php字符串中一个反斜杠应该写成’\\’，将一个反斜杠加以转义，使其成为真正意义上的反斜杠而不是转义字符 所以首先检查字符串，如果其中有一个反斜杠，就将其替换成三个反斜杠，不要纠结为什么是三个，这是官方文档的规定，简单来说就是我们输入一个反斜杠时将这个反斜杠转义就是了 第二次检查字符串中如果有’则被替换成\\’，就是将单引号转义 第三次就是将双引号转义 所以对我们输入的单引号，反斜杠和双引号进行了转义 这个函数的作用就是设置mysql的set-character-client 和 set-character-connection 和 Set-character-results三个参数的值设置为gbk编码 很容易联想到宽字节注入 我们在客户端输入id的值后，经过php服务器提交给mysql，mysql将接受的数据经过set-character-client的编码方式进行编码，再用set-character-connection的编码方式进行编码，然后进入数据库和数据表，根据库和表的默认编码方式进行编码，再将查询结果根据set-character-results编码返回给客户端 而gbk编码方式会将字符串中的两个字符看作是一个汉字，前提是前一个字符的ascii码大于128，所以我们输入id=%df%27时，经由过滤变成’%df%5c%27’，然后经过mysql的编码，认为%df%5c是一个汉字，从而造成单引号不被转义，造成前面单引号不闭合，从而注入 所以只要解决单引号被转义的问题，就与前面关卡没什么区别了 下面爆库 爆表 爆列 这里注意如果输入table_name=’users’，单引号会被转义，可以把users转成十六进制，从而避免使用单引号 延时注入 报错注入 Less-33这关与上一关区别在于使用了addslashes这个函数 这个函数可以将单引号，双引号和反斜杠转义 实际上与上一关功能相同，只不过这个函数可以实现上一关的三个替换功能 一样在单引号前面加上%df即可正常注入 Less-34这关用了POST提交表单的方法，依然对单引号，双引号和反斜杠有转义 查询语句如下： 与之前关卡区别在于，之前是GET方式提交的请求，而我们输入的GET参数是会经过url解码的，而POST则不会经过url解码，所以我们如果按照之前的方法输入username=admin%df’，发现%df不会被解码 所以不如我们替它解码，%df经过url解码后为字符�，所以我们可以输入admin�’ 果然有报错了 那么接下来又思考如何注出用户名和密码，因为username列的数据类型是字符串，不像是之前关卡id列的数据类型是整型，所以此处我们用万能密码 Username=�’ or 1=1# 发现成功注出了用户名和密码 结合查询语句 Select * from users where username=’’ and password=’’ limit 0,1 Select * from users where username=’ �\\’ or 1=1 Gbk编码将�和\\看做一个汉字，or语句逻辑运算，因为1=1恒为1所以条件恒为真，注出users表中所有用户名和密码 在mysql命令行验证一下 那么要注出下面几行的用户名和密码我们只需要加个limit n,1就ok了 其他注入和之前一样 爆库 爆表 爆列 报错注入 这里如果用and会导致前面为假而后面不执行，所以改成or 延时注入 关于延时注入，之前碰到的都是能前面id=某个数字能查到，然后根据某个判断条件执行sleep进行延时注入 而本关注入点username数据类型是字符串，也就是说必须跟列下数据完全一样，才能查的到值，而本关我们要注入，则必须要过滤转义字符从而使单引号逃逸，也就是我们过滤后username的值肯定不可能跟表里的值有相同的，即不能保证前面的值为真，要延时注入，就得用or sleep，or的执行条件前面为前面的条件为假 先查一下users表中又十四行数据 那我们进行延时注入 可见sleep了14秒，因为mysql要对每行数据进行查询，判断username有没有等于1的，如果没有，则执行sleep 1秒，总共要查询14行，14行都没有符合的，所以sleep了总共14秒 而如果是and的话，则是查询到数据才会执行sleep 1秒 在看看之前的过滤单引号的关卡构造闭合单引号的注入语句 为什么能查出所有数据 我觉得应该这样划分(username=‘admin’ and sleep(5)) or ‘1’=’1’，先查有没有等于admin的，如果没有不执行sleep，然后会执行or，执行结果为1. 如果有等于admin的，则执行sleep，但在要执行时，执行了or语句，结果1,不延迟 所以最终结果不管username的值有没有出现在表中，结果都为1，不会执行sleep 要进行注入的话，就必须将or换成and 所以本关延迟注入如图 Less-35试一下id=1%df’%23 发现报错 说明id没有任何包裹，所以本关也不需要宽字节注入，相当于之前的关卡了 Less-36这关跟之前区别在于转义函数用了mysql_real_escape_string() 但由于我们set names gbk，所以还是能用宽字节注入的方法，跟之前关卡一样 下面总结一下再使用addslashes和mysql_real_escape_string如何防御宽字节注入 Less-37 跟之前post关卡一样，只是用了mysql_real_escape_string HTTP参数污染参考链接：http://www.freebuf.com/articles/web/5908.html 宽字节注入参考链接：https://mp.weixin.qq.com/s/WjGaDxwaBkOzCe2BWGak2A","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs23-28","slug":"sql-labs23-28","date":"2018-07-09T05:31:00.000Z","updated":"2018-07-09T13:33:44.950Z","comments":true,"path":"/posts/38551/","link":"","permalink":"https://Foxgrin.github.io/posts/38551/","excerpt":"总结一些sql-labs中带有过滤关键字的关卡","text":"总结一些sql-labs中带有过滤关键字的关卡 Less23-28Less-23 这关对注释符–+和#有过滤 因为id被单引号包裹 解决方法是通过构造payload来闭合单引号 爆数据库 爆表 爆列 如果采取报错注入的话，还有一种方法是通过or ‘1’=’1闭合单引号 如果用count(),group by,floor(rand(0)2)则要用and ‘1’=’1才会报错 延时注入 此处如果用or ‘1’=’1的话会导致后面恒为真，导致前面的sleep不被执行，所以应当换成and ‘1’=’1 Less-25从源代码可以分析出对关键字or 和and有过滤，并且不区分大小写 由于只过滤一次，所以可以用复写关键字的方法注入关键字or和and 爆数据库 爆表 爆列 延时注入 报错注入 Less-25a这关没有报出错误信息，所以考虑用延时注入 看出id没有被引号包裹 Less-26 从源代码分析出过滤了关键字and,or,/*,–,#,空格,/ 解决方法:(1)双写and 和 or ​ (2)使用or ‘1’=’1 闭合单引号 ​ (3) %09 TAB键（水平） ​ %0a 新建一行 ​ %0b TAB键（垂直） ​ %0c 新的一页 ​ %0d return功能 ​ %a0 空格 替代空格，但经过尝试，window下以上所有字符都替代不了空格，迫于无奈只好将源码中过滤空格的语句注释 延时注入 报错注入 联合注入 Less-26a这题没有报错信息，其余与上题一致 延时注入 看出id被(‘’)包裹 因为没有报错信息，所以无法用报错注入 于是用联合注入 爆库 爆表 爆列 Less-27 这关对关键字union和select有过滤 复写union，三写select或者大小写混合即可解决 这里id被单引号包裹 爆库 爆表 爆列 Less-27a这关没有报错信息，输入id=1’ 输入正确结果，因为id为int类型，所以说明id可能被双引号包裹 输入id=1” 查询不到结果，说明被双引号包裹 这关跟上一关一样，对关键字union和select进行了过滤，因为没有报错信息，所以不能用报错注入 联合注入 Less-28 Id被(‘’)包裹，这关没有报错信息，所以用联合注入 发现union和select 同时使用时就会被过滤掉，而且无视大小写 这里解决方法是复写union\\sselect Less-28a 这关只对union\\sselect进行了过滤，无报错信息 复写+联合注入就解决了","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs20","slug":"sql-labs20","date":"2018-07-08T12:17:00.000Z","updated":"2018-07-09T13:33:44.948Z","comments":true,"path":"/posts/47662/","link":"","permalink":"https://Foxgrin.github.io/posts/47662/","excerpt":"sql-labs20通关记录","text":"sql-labs20通关记录 Less-20今天的靶场是Less-20,这关涉及cookie,要深入理解的话我们就一行行分析源代码 首先，来到程序的第一个分支点，$_COOKIE这个变量是能获取到报文头部所包含的cookie字段其中的信息，我们可以分析出如果要执行这个if语句，则cookie的’uname’字段中是没有信息的。 那么网页首先显示的是跟前几个关卡相似的登录页面。接下来来到第一个分支点里的又一个分支点 可以看出当我们在网页中的表单中提交用户名和账号信息时，则开始执行这个if语句 就开始查询数据库里的用户名和密码信息 并且将查询结果的’username’字段中的用户名信息赋值给$cookee 如果查询结果不为空 则设置将cookie中设置名为’uname’的字段，并给该字段赋值$cookee变量的值，也就是之前查询到的用户名信息，并且设置该字段的生存时间如果查询结果为空，则返回一个查询失败的信息 也就是说当我们在网页的表单中输入用户名和密码时，当查询结果不为空时，则在cookie中设置字段值我们用burp抓包看看报文的详细信息 我们先查询一下users表里的信息 接着输入一个users表中存在的用户名和密码 这是我们提交表单给服务器的POST报文，来看看服务器这时返回的信息是什么 可以看出服务器设置了cookie信息 并且返回这些信息，可见这就是一开始的登录页面加上 查询结果后返回的信息那么我们放行这个请求报文，看看接下来发生什么 放行后出现了第二个请求报文，这是个GET请求报文，我们可以看出此时头部已经有了cookie信息，我们再来看看服务器的回应 我们再回头看看源代码，发现此时执行了第二个节点，此时cookie中的’uname’字段已经有了信息，则执行了else语句这个else语句中又包含了一个节点 也就是当我们还未点击submit按钮时会执行这个if语句 然后 返回一些信息 并且以cookee变量的值作为用户名进行数据库的查询然后将查询到的信息输出出来，最后一行会出现一个submit按钮接下来我们放行第二个报文 放行后可以看到网页发生了变化，也就是返回了还未提交submit时的信息我们点击一下submit按钮，这时看看请求的报文格式 可以看出这是一个POST请求报文，这时还又cookie信息，我们再来看看服务器返回的报文 这时服务器发现cookie中的’expires’字段中的时间发生了变化，’uname’字段内容为空时，默认内容为deleted，并且返回 可见当我们点击submit按钮后执行了else语句 放行这个POST请求报文 又出现了一个GET请求报文，看出此时cookie信息已经被删除了 又回到了一开始的登录界面这里就涉及了一个重定向“location”它的作用是不用用户输入网址，它会自动访问，一般是GET请求，所以我们之前能抓到两个请求报文，且网页最后显示是重定向后的最终页面","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs17","slug":"sql-labs17","date":"2018-07-08T12:06:00.000Z","updated":"2018-07-09T13:33:44.947Z","comments":true,"path":"/posts/34927/","link":"","permalink":"https://Foxgrin.github.io/posts/34927/","excerpt":"sql-labs17通关记录","text":"sql-labs17通关记录 Less-17 首先了解到本关是可以改密码，看一下源代码 同样是接收我们输入的username和password，但是这里定义了一个check_input函数 一步步分析这个函数 首先empty这个函数，如果输入值不为空，则返回是false，输入为空，返回true 我们输入的是一个字符串，判断为空的情况的字符串为“”和“0”，所以要执行if语句，则empty返回false，所以输入字符串不为“”和“0”时，截取字符串前十五位 这两个if语句就起到了对输入特殊字符的转义的作用，get_magic_quotes_gpc()这个函数当系统有对特定字符转义时返回true，没有返回false，当有转义时，执行if语句，stripslashes()函数将转义字符丢弃，ctype_digit()函数判断当字符串值不为0或者正整数时返回false，则会将输入的字符串加上’’并且对特殊字符转义 我们首先先输入两个admin，可以看到提示修改密码成功，再看一下result.txt里面输入的值 可以发现我们输入admin这个字符串两边被加了单引号，我们试试用户名admin’ 提示错误，说明查询结果为空，从txt文件可以看到 对我们输入的’进行了转义，说明username无法进行一个注入，我们再试着在用户名输入0 发现修改成功 从txt文件 看出输入字符串为0所以没有加单引号所以这题的注入点应该是password，我们先试试 果然出现了报错信息 没有报错，说明password被单引号包裹,我们来试试基于报错型的注入 结果显示 再试试基于时间的报错型注入 按理来说应该会sleep 13秒，因为没有指定修改条件，会一行行的修改，而users表里有十三行，所以修改十三次。 但从结果来看并没有sleep 这是为什么呢，这个问题我也想了好久好久，最终学长点醒了我，原来是and的优先级大于=，所以先执行’admin’ and if()语句，而字符串里没有数字时是无法做and运算的，就无法执行后面的if语句 我们试着把密码加一个数字 果然结果sleep了13秒，学长建议通过where后的条件进行注入以免意外的错误 于是我们开始爆表名 爆列名 爆数据","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]}]}